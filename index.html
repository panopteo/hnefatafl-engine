<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hnefatafl Engine (Copenhagen Rules)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #070a11;
      --panel: #0f1624;
      --panel-border: rgba(255, 255, 255, 0.05);
      --accent: #8ad0ff;
      --accent-strong: #58a6ff;
      --text: #f4f7ff;
      --muted: #96a3ba;
      --board-bright: #f5e3c0;
      --board-special: #8d623b;
      --attacker: #1c1d21;
      --defender: #fdfcfa;
      --king: #f4c95d;
      --legal-dot: rgba(137, 208, 255, 0.92);
      --last-move-from: rgba(88, 134, 255, 0.45);
      --last-move-to: rgba(234, 197, 119, 0.6);
      --capture-flash: rgba(255, 116, 116, 0.5);
      --toast-bg: rgba(8, 11, 18, 0.92);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #131b2e, var(--bg));
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem 4rem;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.75rem, 4vw, 2.5rem);
      letter-spacing: 0.04em;
    }

    .app-shell {
      width: min(1200px, 100%);
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }

    .panel {
      background: var(--panel);
      border-radius: 1.25rem;
      padding: 1.25rem;
      border: 1px solid var(--panel-border);
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.45);
    }

    .board-panel {
      grid-column: span 2;
      padding: 1.75rem;
    }

    .toolbar {
      display: flex;
      gap: 1.25rem;
      flex-wrap: wrap;
    }

    .controls,
    .status {
      flex: 1;
      min-width: 240px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .controls label,
    .status p,
    .telemetry label,
    .engine-stats-panel label {
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 0.25rem;
    }

    select,
    .primary-btn,
    .ghost-btn {
      width: 100%;
      padding: 0.85rem 1rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }

    .primary-btn:hover,
    .ghost-btn:hover,
    select:focus-visible {
      background: rgba(138, 208, 255, 0.18);
      transform: translateY(-1px);
    }

    .ghost-btn {
      width: auto;
      padding: 0.65rem 0.9rem;
      font-size: 0.9rem;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .toggle-row input[type="checkbox"] {
      width: 1.15rem;
      height: 1.15rem;
      accent-color: var(--accent-strong);
    }

    .status .badge {
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      width: fit-content;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .badge.attackers {
      background: rgba(28, 29, 33, 0.45);
      color: #f2f4ff;
    }

    .badge.defenders {
      background: rgba(253, 252, 250, 0.12);
      color: var(--defender);
      border-color: rgba(253, 252, 250, 0.2);
    }

    .status .message {
      font-size: 1rem;
      color: var(--text);
      line-height: 1.5;
      min-height: 2.5rem;
    }

    .board-wrapper {
      position: relative;
      margin-top: 1.25rem;
      width: min(92vw, 640px);
      max-width: 100%;
      margin-left: auto;
      margin-right: auto;
    }

    .engine-status-line {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 0.35rem;
      display: flex;
      gap: 0.4rem;
      align-items: center;
    }

    .engine-status-line span {
      color: var(--text);
      font-weight: 600;
    }

    .board-grid {
      display: grid;
      grid-template-columns: repeat(11, 1fr);
      grid-auto-rows: 1fr;
      gap: 4px;
      width: 100%;
      aspect-ratio: 1;
      padding: 0.85rem;
      border-radius: 1.25rem;
      background: radial-gradient(circle at top, #c9ad88, #9b6d44);
      box-shadow: inset 0 1px 20px rgba(0, 0, 0, 0.45);
    }

    .cell {
      position: relative;
      border: none;
      border-radius: 0.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1;
      padding: 0;
      transition: transform 140ms ease, box-shadow 140ms ease;
    }

    .cell-bright {
      background: var(--board-bright);
    }

    .cell-special {
      background: var(--board-special);
    }

    .cell:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .cell:hover {
      transform: translateY(-2px);
    }

    .cell.selected {
      box-shadow: inset 0 0 0 3px rgba(138, 208, 255, 0.85);
    }

    .cell::before {
      content: "";
      position: absolute;
      inset: 6%;
      border-radius: 0.45rem;
      opacity: 0;
      transition: opacity 160ms ease;
      pointer-events: none;
    }

    .cell.last-move-from::before {
      background: var(--last-move-from);
      opacity: 1;
    }

    .cell.last-move-to::before {
      background: var(--last-move-to);
      opacity: 1;
    }

    .cell.capture-flash::before {
      background: var(--capture-flash);
      opacity: 1;
    }

    .cell.legal-move::after {
      content: "";
      width: 28%;
      height: 28%;
      background: var(--legal-dot);
      border-radius: 50%;
      box-shadow: 0 0 12px rgba(138, 208, 255, 0.8);
      opacity: 0.85;
      pointer-events: none;
    }

    .piece {
      width: 70%;
      aspect-ratio: 1;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: clamp(0.85rem, 1.8vw, 1.2rem);
      letter-spacing: 0.02em;
      pointer-events: none;
    }

    .piece.attacker {
      background: radial-gradient(circle at 30% 30%, #3c3c43, var(--attacker));
      color: #f2f4ff;
      border: 2px solid rgba(255, 255, 255, 0.18);
      box-shadow: inset 0 6px 12px rgba(255, 255, 255, 0.08);
    }

    .piece.defender {
      background: radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9);
      color: #1d1c19;
      border: 2px solid rgba(0, 0, 0, 0.15);
      box-shadow: inset 0 6px 12px rgba(0, 0, 0, 0.08);
    }

    .piece.king {
      background: radial-gradient(circle at 30% 30%, #ffeeb7, var(--king));
      border: 2px solid #c38b29;
      color: #2b1d07;
      font-size: clamp(1rem, 2.5vw, 1.45rem);
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.75);
      box-shadow: inset 0 8px 16px rgba(255, 255, 255, 0.25);
    }

    .capture-toast {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translate(-50%, 140%);
      padding: 0.55rem 1.2rem;
      border-radius: 999px;
      background: var(--toast-bg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text);
      opacity: 0;
      transition: opacity 200ms ease, transform 200ms ease;
      pointer-events: none;
    }

    .capture-toast.visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .transcript {
      max-height: 420px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .move-row {
      display: flex;
      align-items: baseline;
      gap: 0.65rem;
      font-variant-numeric: tabular-nums;
      padding-bottom: 0.45rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .move-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .move-index {
      color: var(--muted);
      width: 2.5rem;
    }

    .move-text {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .move-side {
      text-transform: capitalize;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .move-description {
      font-weight: 600;
    }

    .telemetry {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .telemetry h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .engine-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }

    .stat-card {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 0.85rem;
      padding: 0.8rem;
      background: rgba(255, 255, 255, 0.02);
    }

    .stat-card span {
      display: block;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 0.15rem;
    }

    .stat-card strong {
      font-size: 1.3rem;
    }

    .engine-pv {
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      font-size: 0.85rem;
      color: var(--muted);
      min-height: 1.6rem;
    }

    .telemetry-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .log-viewer {
      width: 100%;
      min-height: 200px;
      border-radius: 0.85rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.25);
      color: var(--text);
      padding: 0.75rem;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      font-size: 0.85rem;
      resize: vertical;
    }

    .telemetry-note,
    .test-status,
    .engine-status-log {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .test-status.good {
      color: #7ee787;
    }

    .test-status.bad {
      color: #ff7b72;
    }

    @media (max-width: 900px) {
      .board-panel {
        grid-column: span 1;
      }

      .board-wrapper {
        width: 100%;
      }

      .board-grid {
        gap: 3px;
        padding: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <h1>Hnefatafl Engine · Copenhagen Rules</h1>
  <div class="app-shell">
    <section class="panel board-panel">
      <div class="toolbar">
        <div class="controls">
          <div>
            <label for="sideSelect">Play as</label>
            <select id="sideSelect">
              <option value="defenders">Defenders (White)</option>
              <option value="attackers">Attackers (Black)</option>
            </select>
          </div>
          <div>
            <label for="difficultySelect">Difficulty</label>
            <select id="difficultySelect">
              <option value="casual">Casual · 0.2s/move</option>
              <option value="standard">Standard · 1s/move</option>
              <option value="strong" selected>Strong · 3s/move</option>
            </select>
          </div>
          <button class="primary-btn" id="restartBtn">Restart Game</button>
          <div class="toggle-row">
            <input type="checkbox" id="exitFortToggle" />
            <span>Exit Fort win (experimental)</span>
          </div>
        </div>
        <div class="status">
          <div>
            <p>Current Turn</p>
            <span id="turnBadge" class="badge attackers">Attackers</span>
          </div>
          <div>
            <p>Game State</p>
            <div id="statusMessage" class="message">Attackers to move.</div>
          </div>
          <div class="engine-status-line">
            Engine:
            <span id="engineStatus">Idle</span>
          </div>
        </div>
      </div>
      <div class="board-wrapper">
        <div id="board" class="board-grid" aria-label="Copenhagen Hnefatafl board"></div>
        <div id="captureToast" class="capture-toast" aria-live="assertive"></div>
      </div>
    </section>

    <section class="panel transcript" aria-live="polite" aria-label="Move transcript">
      <h2 style="margin-top:0; font-size:1.1rem;">Move List</h2>
      <div id="moves"></div>
    </section>

    <section class="panel telemetry">
      <h2>Diagnostics & Engine Telemetry</h2>
      <div class="engine-stats-grid">
        <div class="stat-card">
          <span>Depth</span>
          <strong id="statDepth">–</strong>
        </div>
        <div class="stat-card">
          <span>Nodes</span>
          <strong id="statNodes">–</strong>
        </div>
        <div class="stat-card">
          <span>Eval</span>
          <strong id="statEval">–</strong>
        </div>
        <div class="stat-card">
          <span>Time</span>
          <strong id="statTime">–</strong>
        </div>
      </div>
      <div class="engine-pv" id="statPV">PV: —</div>
      <div class="telemetry-actions">
        <button class="ghost-btn" id="refreshLogsBtn">Refresh view</button>
        <button class="ghost-btn" id="downloadJsonBtn">Download JSON</button>
        <button class="ghost-btn" id="downloadCsvBtn">Download CSV</button>
        <button class="ghost-btn" id="clearLogsBtn">Clear logs</button>
        <button class="ghost-btn" id="copyBugBtn">Copy bug report</button>
        <button class="ghost-btn" id="selfPlayBtn">Self-play x3</button>
      </div>
      <div id="testStatus" class="test-status">Regression tests pending…</div>
      <textarea id="logViewer" class="log-viewer" readonly></textarea>
      <div id="telemetryNote" class="telemetry-note">No game logs yet.</div>
    </section>
  </div>

  <script id="engine-worker" type="javascript/worker">
    (() => {
      const SIZE = 11;
      const CENTER = Math.floor(SIZE / 2);
      const Piece = Object.freeze({ EMPTY: '.', ATTACKER: 'A', DEFENDER: 'D', KING: 'K' });
      const Side = Object.freeze({ ATTACKERS: 'attackers', DEFENDERS: 'defenders' });
      const restrictedSquares = new Set([
        `${CENTER},${CENTER}`,
        `0,0`, `0,${SIZE - 1}`, `${SIZE - 1},0`, `${SIZE - 1},${SIZE - 1}`
      ]);
      const throneKey = `${CENTER},${CENTER}`;
      const directions = [ [1, 0], [-1, 0], [0, 1], [0, -1] ];

      const zobrist = (() => {
        const values = [];
        let seed = 1234567;
        const rand = () => {
          seed ^= seed << 13;
          seed ^= seed >> 17;
          seed ^= seed << 5;
          return (seed >>> 0) / 0xffffffff;
        };
        for (let idx = 0; idx < SIZE * SIZE * 4; idx++) {
          values.push(BigInt(Math.floor(rand() * Number.MAX_SAFE_INTEGER)));
        }
        const sideValue = BigInt(0x9e3779b97f4a7c15);
        return {
          table: values,
          sideValue
        };
      })();

      function pieceIndex(piece) {
        if (piece === Piece.ATTACKER) return 0;
        if (piece === Piece.DEFENDER) return 1;
        if (piece === Piece.KING) return 2;
        return 3;
      }

      function zobristIndex(r, c, piece) {
        return ((r * SIZE + c) * 4) + pieceIndex(piece);
      }

      function hashBoard(board, side) {
        let hash = 0n;
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const cell = board[r][c];
            if (cell === Piece.EMPTY) continue;
            hash ^= zobrist.table[zobristIndex(r, c, cell)];
          }
        }
        if (side === Side.ATTACKERS) hash ^= zobrist.sideValue;
        return hash;
      }

      function cloneBoard(board) {
        return board.map(row => row.slice());
      }

      function coordKey(r, c) {
        return `${r},${c}`;
      }

      function isInside(r, c) {
        return r >= 0 && c >= 0 && r < SIZE && c < SIZE;
      }

      function isCorner(r, c) {
        return (r === 0 || r === SIZE - 1) && (c === 0 || c === SIZE - 1);
      }

      function isRestricted(r, c) {
        return restrictedSquares.has(coordKey(r, c));
      }

      function pieceBelongsTo(piece, side) {
        if (piece === Piece.EMPTY) return false;
        if (side === Side.ATTACKERS) return piece === Piece.ATTACKER;
        return piece === Piece.DEFENDER || piece === Piece.KING;
      }

      function opposite(side) {
        return side === Side.ATTACKERS ? Side.DEFENDERS : Side.ATTACKERS;
      }

      function isHostileSquareAgainst(side, r, c, board) {
        const key = coordKey(r, c);
        if (key === throneKey) {
          if (side === Side.ATTACKERS) return true;
          return board[r][c] === Piece.EMPTY;
        }
        if (isCorner(r, c)) {
          return board[r][c] === Piece.EMPTY || !pieceBelongsTo(board[r][c], side);
        }
        return false;
      }

      function getLegalMoves(board, r, c, side) {
        const piece = board[r][c];
        if (!pieceBelongsTo(piece, side)) return [];
        const moves = [];
        for (const [dr, dc] of directions) {
          let nr = r + dr;
          let nc = c + dc;
          while (isInside(nr, nc) && board[nr][nc] === Piece.EMPTY) {
            if (isRestricted(nr, nc) && piece !== Piece.KING) {
              if (coordKey(nr, nc) === throneKey) {
                nr += dr;
                nc += dc;
                continue;
              }
              break;
            }
            moves.push([nr, nc]);
            nr += dr;
            nc += dc;
          }
        }
        return moves;
      }

      function movePiece(board, from, to) {
        const newBoard = cloneBoard(board);
        const [fr, fc] = from;
        const [tr, tc] = to;
        newBoard[tr][tc] = newBoard[fr][fc];
        newBoard[fr][fc] = Piece.EMPTY;
        return newBoard;
      }

      function maybeCaptureKing(board, pos) {
        const [r, c] = pos;
        if (r === 0 || r === SIZE - 1 || c === 0 || c === SIZE - 1) {
          return false;
        }

        const onThrone = coordKey(r, c) === throneKey;
        const adjacentToThrone = Math.abs(r - CENTER) + Math.abs(c - CENTER) === 1;

        // Copenhagen nuance (bugfix): when the king is adjacent to the throne,
        // the throne itself does NOT count as the 3rd capturing side if empty.
        // We require THREE attackers on the three non-throne sides.
        if (adjacentToThrone && !onThrone) {
          // The throne side never counts toward capturing the king, even if empty.
          // Capture requires attackers on ALL three non-throne adjacent squares.
          const nonThroneAdj = [];
          for (const [dr, dc] of directions) {
            const nr = r + dr;
            const nc = c + dc;
            if (!isInside(nr, nc)) continue;
            if (coordKey(nr, nc) === throneKey) continue;
            nonThroneAdj.push([nr, nc]);
          }
          return nonThroneAdj.length === 3 && nonThroneAdj.every(([nr, nc]) => board[nr][nc] === Piece.ATTACKER);
        }

        // Default: king capture requires 4 hostile sides.
        // Hostile sides include attackers, corners, and (for non-adjacent cases) an empty throne.
        let hostileCount = 0;
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) continue;
          const occupant = board[nr][nc];
          if (occupant === Piece.ATTACKER) {
            hostileCount += 1;
            continue;
          }
          if (isHostileSquareAgainst(Side.DEFENDERS, nr, nc, board)) {
            hostileCount += 1;
          }
        }
        const required = 4; // including on-throne (Copenhagen)
        return hostileCount >= required;
      }

      function applyShieldwall(board, moverSide) {
        const opponent = opposite(moverSide);
        const captured = [];
        const bracketSatisfied = (row, col) => {
          if (!isInside(row, col)) return false;
          if (isCorner(row, col)) return true;
          return pieceBelongsTo(board[row][col], moverSide);
        };

        const scanHorizontal = (edgeRow) => {
          const innerRow = edgeRow === 0 ? 1 : SIZE - 2;
          let col = 0;
          while (col < SIZE) {
            if (!pieceBelongsTo(board[edgeRow][col], opponent)) {
              col += 1;
              continue;
            }
            const start = col;
            while (col < SIZE && pieceBelongsTo(board[edgeRow][col], opponent)) {
              col += 1;
            }
            const end = col - 1;
            if (end - start + 1 < 2) continue;
            const leftIdx = start - 1;
            const rightIdx = end + 1;
            const touchesLeftCorner = start === 0 && isCorner(edgeRow, 0);
            const touchesRightCorner = end === SIZE - 1 && isCorner(edgeRow, SIZE - 1);
            const leftOk = touchesLeftCorner || (leftIdx >= 0 && bracketSatisfied(edgeRow, leftIdx));
            const rightOk = touchesRightCorner || (rightIdx < SIZE && bracketSatisfied(edgeRow, rightIdx));
            if (!leftOk || !rightOk) continue;
            let support = true;
            for (let c = start; c <= end; c++) {
              if (!pieceBelongsTo(board[innerRow][c], moverSide)) {
                support = false;
                break;
              }
            }
            if (!support) continue;
            for (let c = start; c <= end; c++) {
              if (board[edgeRow][c] === Piece.KING) continue;
              captured.push({ r: edgeRow, c, piece: board[edgeRow][c] });
              board[edgeRow][c] = Piece.EMPTY;
            }
          }
        };

        const scanVertical = (edgeCol) => {
          const innerCol = edgeCol === 0 ? 1 : SIZE - 2;
          let row = 0;
          while (row < SIZE) {
            if (!pieceBelongsTo(board[row][edgeCol], opponent)) {
              row += 1;
              continue;
            }
            const start = row;
            while (row < SIZE && pieceBelongsTo(board[row][edgeCol], opponent)) {
              row += 1;
            }
            const end = row - 1;
            if (end - start + 1 < 2) continue;
            const topIdx = start - 1;
            const bottomIdx = end + 1;
            const touchesTopCorner = start === 0 && isCorner(0, edgeCol);
            const touchesBottomCorner = end === SIZE - 1 && isCorner(SIZE - 1, edgeCol);
            const topOk = touchesTopCorner || (topIdx >= 0 && bracketSatisfied(topIdx, edgeCol));
            const bottomOk = touchesBottomCorner || (bottomIdx < SIZE && bracketSatisfied(bottomIdx, edgeCol));
            if (!topOk || !bottomOk) continue;
            let support = true;
            for (let r = start; r <= end; r++) {
              if (!pieceBelongsTo(board[r][innerCol], moverSide)) {
                support = false;
                break;
              }
            }
            if (!support) continue;
            for (let r = start; r <= end; r++) {
              if (board[r][edgeCol] === Piece.KING) continue;
              captured.push({ r, c: edgeCol, piece: board[r][edgeCol] });
              board[r][edgeCol] = Piece.EMPTY;
            }
          }
        };

        scanHorizontal(0);
        scanHorizontal(SIZE - 1);
        scanVertical(0);
        scanVertical(SIZE - 1);
        return captured;
      }

      function captureEnemyPieces(board, movedTo, moverSide) {
        const newBoard = cloneBoard(board);
        const opponent = opposite(moverSide);
        const captured = [];
        for (const [dr, dc] of directions) {
          const adjR = movedTo[0] + dr;
          const adjC = movedTo[1] + dc;
          if (!isInside(adjR, adjC)) continue;
          const adjPiece = newBoard[adjR][adjC];
          if (!pieceBelongsTo(adjPiece, opponent)) continue;
          if (adjPiece === Piece.KING) {
            if (maybeCaptureKing(newBoard, [adjR, adjC])) {
              newBoard[adjR][adjC] = Piece.EMPTY;
              captured.push({ r: adjR, c: adjC, piece: Piece.KING });
            }
            continue;
          }
          const beyondR = adjR + dr;
          const beyondC = adjC + dc;
          const beyondHostile =
            (isInside(beyondR, beyondC) && pieceBelongsTo(newBoard[beyondR][beyondC], moverSide)) ||
            (isInside(beyondR, beyondC) && isHostileSquareAgainst(opponent, beyondR, beyondC, newBoard));
          if (beyondHostile) {
            newBoard[adjR][adjC] = Piece.EMPTY;
            captured.push({ r: adjR, c: adjC, piece: adjPiece });
          }
        }
        const shieldCaptures = applyShieldwall(newBoard, moverSide);
        return { board: newBoard, captured: [...captured, ...shieldCaptures] };
      }

      function locateKing(board) {
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (board[r][c] === Piece.KING) return [r, c];
          }
        }
        return null;
      }

      function defendersEncircled(board) {
        const kingPos = locateKing(board);
        if (!kingPos) return true;
        const visited = new Set();
        const queue = [kingPos];
        visited.add(coordKey(...kingPos));
        while (queue.length) {
          const [r, c] = queue.shift();
          if (r === 0 || c === 0 || r === SIZE - 1 || c === SIZE - 1) {
            return false;
          }
          for (const [dr, dc] of directions) {
            const nr = r + dr;
            const nc = c + dc;
            if (!isInside(nr, nc)) continue;
            const key = coordKey(nr, nc);
            if (visited.has(key)) continue;
            const cell = board[nr][nc];
            if (cell === Piece.EMPTY || pieceBelongsTo(cell, Side.DEFENDERS)) {
              visited.add(key);
              queue.push([nr, nc]);
            }
          }
        }
        return true;
      }

      function hasLegalMove(board, side) {
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (pieceBelongsTo(board[r][c], side) && getLegalMoves(board, r, c, side).length) {
              return true;
            }
          }
        }
        return false;
      }

      function attackersCanCaptureKing(board) {
        const moves = allMoves(board, Side.ATTACKERS);
        for (const mv of moves) {
          const next = simulateMove(board, mv);
          if (!locateKing(next)) {
            return true;
          }
        }
        return false;
      }

      function defendersExitFort(board) {
        const kingPos = locateKing(board);
        if (!kingPos) return false;
        const [kr, kc] = kingPos;
        const onEdge = kr === 0 || kc === 0 || kr === SIZE - 1 || kc === SIZE - 1;
        if (!onEdge) return false;
        const kingMoves = getLegalMoves(board, kr, kc, Side.DEFENDERS);
        if (!kingMoves.length) return false;
        return !attackersCanCaptureKing(board);
      }

      function determineWin(board, config) {
        const kingPos = locateKing(board);
        if (!kingPos) {
          return { winner: Side.ATTACKERS, reason: 'King captured' };
        }
        if (isCorner(...kingPos)) {
          return { winner: Side.DEFENDERS, reason: 'King escaped' };
        }
        if (config.exitFortEnabled && defendersExitFort(board)) {
          return { winner: Side.DEFENDERS, reason: 'Exit fort' };
        }
        if (defendersEncircled(board)) {
          return { winner: Side.ATTACKERS, reason: 'Encirclement' };
        }
        if (!hasLegalMove(board, Side.ATTACKERS)) {
          return { winner: Side.DEFENDERS, reason: 'Attackers stalemated' };
        }
        if (!hasLegalMove(board, Side.DEFENDERS)) {
          return { winner: Side.ATTACKERS, reason: 'Defenders stalemated' };
        }
        return null;
      }

      function simulateMove(board, move) {
        const shifted = movePiece(board, move.from, move.to);
        const result = captureEnemyPieces(shifted, move.to, move.side);
        return result.board;
      }

      function allMoves(board, side) {
        const moves = [];
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (!pieceBelongsTo(board[r][c], side)) continue;
            const legal = getLegalMoves(board, r, c, side);
            for (const [nr, nc] of legal) {
              moves.push({ side, from: [r, c], to: [nr, nc] });
            }
          }
        }
        return moves;
      }

      function evaluateBoard(board, side, config) {
        const win = determineWin(board, config);
        if (win) {
          if (win.winner === side) return 5000;
          if (win.winner === opposite(side)) return -5000;
        }
        let attackers = 0;
        let defenders = 0;
        let kingSafety = 0;
        let kingMobility = 0;
        const kingPos = locateKing(board);
        if (!kingPos) {
          return side === Side.ATTACKERS ? 4000 : -4000;
        }
        const corners = [ [0,0], [0,SIZE-1], [SIZE-1,0], [SIZE-1,SIZE-1] ];
        let minCorner = Infinity;
        for (const [cr, cc] of corners) {
          const dist = Math.abs(cr - kingPos[0]) + Math.abs(cc - kingPos[1]);
          if (dist < minCorner) minCorner = dist;
        }
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const cell = board[r][c];
            if (cell === Piece.ATTACKER) attackers += 1;
            if (cell === Piece.DEFENDER) defenders += 1;
            if (cell === Piece.KING) {
              const centerDist = Math.abs(r - CENTER) + Math.abs(c - CENTER);
              kingSafety -= centerDist * 3;
              if (isCorner(r, c)) kingSafety += 500;
            }
          }
        }
        const kingMoves = getLegalMoves(board, kingPos[0], kingPos[1], Side.DEFENDERS).length;
        kingMobility += kingMoves * 8;
        const material = (defenders * 35 + 250) - attackers * 25;
        const escapeBonus = (SIZE * 2 - minCorner) * 6;
        let score = material + kingSafety + escapeBonus + kingMobility;
        if (defendersEncircled(board)) score -= 600;
        if (!hasLegalMove(board, Side.DEFENDERS)) score -= 1000;
        if (!hasLegalMove(board, Side.ATTACKERS)) score += 1000;
        return side === Side.DEFENDERS ? score : -score;
      }

      function scoreMove(board, move, config) {
        const shifted = movePiece(board, move.from, move.to);
        const { board: after, captured } = captureEnemyPieces(shifted, move.to, move.side);
        let score = 0;
        captured.forEach(cap => {
          if (cap.piece === Piece.KING) score += 10000;
          if (cap.piece === Piece.DEFENDER) score += 250;
          if (cap.piece === Piece.ATTACKER) score += 180;
        });
        const win = determineWin(after, config);
        if (win?.winner === move.side) score += 5000;
        if (move.side === Side.DEFENDERS && after[move.to[0]][move.to[1]] === Piece.KING) {
          const corners = [ [0,0], [0,SIZE-1], [SIZE-1,0], [SIZE-1,SIZE-1] ];
          let minCorner = Infinity;
          for (const [cr, cc] of corners) {
            const dist = Math.abs(cr - move.to[0]) + Math.abs(cc - move.to[1]);
            if (dist < minCorner) minCorner = dist;
          }
          score += (SIZE * 2 - minCorner) * 10;
        }
        return score;
      }

      function orderMoves(board, moves, heuristics, config) {
        return moves
          .map(m => ({ move: m, score: (heuristics.tt?.has(hashBoard(applyMove(board, m, config), opposite(m.side))) ? 50 : 0) + scoreMove(board, m, config) }))
          .sort((a, b) => b.score - a.score)
          .map(entry => entry.move);
      }

      function applyMove(board, move, config) {
        const shifted = movePiece(board, move.from, move.to);
        const { board: after } = captureEnemyPieces(shifted, move.to, move.side);
        return after;
      }

      class SearchController {
        constructor(settings, config) {
          this.settings = settings;
          this.config = config;
          this.deadline = performance.now() + settings.moveTimeMs - 20;
          this.nodes = 0;
          this.cutNodes = 0;
          this.ttHits = 0;
          this.transposition = new Map();
          this.killerMoves = new Map();
          this.timeout = false;
        }

        shouldStop() {
          if (this.timeout) return true;
          if (performance.now() > this.deadline) {
            this.timeout = true;
            return true;
          }
          return false;
        }

        makeKey(board, side) {
          return hashBoard(board, side);
        }

        storeTT(key, depth, score, flag, bestMove) {
          this.transposition.set(key, { depth, score, flag, bestMove });
        }

        lookupTT(key, depth, alpha, beta) {
          const entry = this.transposition.get(key);
          if (!entry) return null;
          this.ttHits += 1;
          if (entry.depth >= depth) {
            if (entry.flag === 'EXACT') return entry.score;
            if (entry.flag === 'LOWER' && entry.score > alpha) return entry.score;
            if (entry.flag === 'UPPER' && entry.score < beta) return entry.score;
          }
          return entry;
        }
      }

      function negamax(board, depth, alpha, beta, side, controller, ply, pvLine) {
        if (controller.shouldStop()) {
          return { score: 0, pv: [] };
        }
        const win = determineWin(board, controller.config);
        if (win) {
          if (win.winner === side) {
            return { score: 4000 - ply, pv: [] };
          }
          if (win.winner === opposite(side)) {
            return { score: -4000 + ply, pv: [] };
          }
        }
        if (depth === 0) {
          return { score: evaluateBoard(board, side, controller.config), pv: [] };
        }
        controller.nodes += 1;
        const key = controller.makeKey(board, side);
        const ttResult = controller.lookupTT(key, depth, alpha, beta);
        if (typeof ttResult === 'number') {
          return { score: ttResult, pv: [] };
        }
        let moves = allMoves(board, side);
        if (!moves.length) {
          return { score: evaluateBoard(board, side, controller.config), pv: [] };
        }
        const heuristics = { tt: controller.transposition };
        moves = moves
          .map(move => ({ move, score: scoreMove(board, move, controller.config) }))
          .sort((a, b) => b.score - a.score)
          .map(entry => entry.move);
        let bestMove = null;
        let bestPV = [];
        let flag = 'UPPER';
        for (const move of moves) {
          const nextBoard = applyMove(board, move, controller.config);
          const child = negamax(nextBoard, depth - 1, -beta, -alpha, opposite(side), controller, ply + 1);
          if (controller.timeout) {
            return { score: 0, pv: [] };
          }
          const score = -child.score;
          if (score > alpha) {
            alpha = score;
            bestMove = move;
            bestPV = [move, ...child.pv];
            flag = 'EXACT';
          }
          if (alpha >= beta) {
            controller.cutNodes += 1;
            flag = 'LOWER';
            break;
          }
        }
        if (bestMove) {
          controller.storeTT(key, depth, alpha, flag, bestMove);
        }
        return { score: alpha, move: bestMove, pv: bestPV };
      }

      function iterativeDeepening(board, side, settings, config) {
        const controller = new SearchController(settings, config);
        const startedAt = performance.now();
        let best = null;
        let bestScore = 0;
        let bestDepth = 0;
        let bestPV = [];
        for (let depth = 1; depth <= settings.maxDepth; depth += 1) {
          if (controller.shouldStop()) break;
          const result = negamax(board, depth, -Infinity, Infinity, side, controller, 0);
          if (controller.timeout) break;
          if (result.move) {
            best = result.move;
            bestScore = result.score;
            bestDepth = depth;
            bestPV = [result.move, ...result.pv];
          }
        }
        if (!best) {
          const moves = allMoves(board, side);
          best = moves[Math.floor(Math.random() * moves.length)] || null;
          bestDepth = 1;
          bestScore = 0;
          bestPV = best ? [best] : [];
        }
        const elapsed = Math.max(0, performance.now() - startedAt);
        return {
          move: best,
          stats: {
            depth: bestDepth,
            nodes: controller.nodes,
            eval: bestScore,
            timeMs: elapsed,
            pv: bestPV,
            ttHits: controller.ttHits
          }
        };
      }

      function playSelfGame(settings, config, maxPly) {
        let board = cloneBoard(config.initialBoard ?? config.board ?? []);
        if (!board.length) {
          throw new Error('Self-play requires starting board snapshot');
        }
        let side = Side.ATTACKERS;
        const history = [];
        for (let ply = 0; ply < maxPly; ply++) {
          const { move } = iterativeDeepening(board, side, settings, config);
          if (!move) break;
          history.push({ side, move });
          board = applyMove(board, move, config);
          const win = determineWin(board, config);
          if (win) {
            return { winner: win.winner, ply: ply + 1, history };
          }
          side = opposite(side);
        }
        return { winner: null, ply: maxPly, history };
      }

      function runWorkerSelfTests() {
        const failures = [];

        const emptyBoard = () => Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));

        // Adjacent-to-throne king capture requires 3 attackers on non-throne sides.
        // Test all 4 adjacency orientations (king N/E/S/W of throne).
        {
          const cases = [
            { name: 'E', king: [CENTER, CENTER + 1], throneSide: [CENTER, CENTER] },
            { name: 'W', king: [CENTER, CENTER - 1], throneSide: [CENTER, CENTER] },
            { name: 'N', king: [CENTER - 1, CENTER], throneSide: [CENTER, CENTER] },
            { name: 'S', king: [CENTER + 1, CENTER], throneSide: [CENTER, CENTER] }
          ];

          const adj = (r, c) => [
            [r - 1, c],
            [r + 1, c],
            [r, c - 1],
            [r, c + 1]
          ].filter(([ar, ac]) => isInside(ar, ac));

          for (const cs of cases) {
            // 2 attackers + empty throne on the 3rd non-throne side missing => MUST NOT capture.
            {
              const b = emptyBoard();
              b[CENTER][CENTER] = Piece.EMPTY;
              const [kr, kc] = cs.king;
              b[kr][kc] = Piece.KING;
              const nonThrone = adj(kr, kc).filter(([ar, ac]) => coordKey(ar, ac) !== throneKey);
              // Put attackers on first two non-throne sides; leave third empty.
              b[nonThrone[0][0]][nonThrone[0][1]] = Piece.ATTACKER;
              b[nonThrone[1][0]][nonThrone[1][1]] = Piece.ATTACKER;
              if (maybeCaptureKing(b, [kr, kc])) failures.push(`king-adj-throne-2A-no-capture-${cs.name}`);
            }

            // 3 attackers on all non-throne sides => capture.
            {
              const b = emptyBoard();
              b[CENTER][CENTER] = Piece.EMPTY;
              const [kr, kc] = cs.king;
              b[kr][kc] = Piece.KING;
              const nonThrone = adj(kr, kc).filter(([ar, ac]) => coordKey(ar, ac) !== throneKey);
              for (const [ar, ac] of nonThrone) b[ar][ac] = Piece.ATTACKER;
              if (!maybeCaptureKing(b, [kr, kc])) failures.push(`king-adj-throne-3A-captures-${cs.name}`);
            }
          }
        }

        // Exact Alex bug geometry orientation (as asserted in UI regression):
        // king at F7, N=A, E=A, W=D, S=empty throne => MUST NOT capture.
        {
          const b = emptyBoard();
          b[CENTER][CENTER] = Piece.EMPTY; // throne
          b[CENTER - 1][CENTER] = Piece.KING; // one step north of throne (so S is throne)
          b[CENTER - 2][CENTER] = Piece.ATTACKER; // N
          b[CENTER - 1][CENTER + 1] = Piece.ATTACKER; // E
          b[CENTER - 1][CENTER - 1] = Piece.DEFENDER; // W
          if (maybeCaptureKing(b, [CENTER - 1, CENTER])) failures.push('alex-geometry-no-capture');
        }

        // Positive case: 3 attackers on non-throne sides => capture.
        {
          const b = emptyBoard();
          b[CENTER][CENTER] = Piece.EMPTY;
          b[CENTER][CENTER + 1] = Piece.KING;
          b[CENTER - 1][CENTER + 1] = Piece.ATTACKER; // N
          b[CENTER + 1][CENTER + 1] = Piece.ATTACKER; // S
          b[CENTER][CENTER + 2] = Piece.ATTACKER;     // E
          if (!maybeCaptureKing(b, [CENTER, CENTER + 1])) failures.push('king-adj-throne-3A-captures');
        }

        // Adjacent-to-throne: throne occupancy must NOT count as a capturing side.
        // Even if the throne is (illegally) occupied, capture still requires 3 attackers on non-throne sides.
        {
          const b = emptyBoard();
          b[CENTER][CENTER] = Piece.ATTACKER; // occupied throne should not help capture
          b[CENTER][CENTER + 1] = Piece.KING;
          b[CENTER - 1][CENTER + 1] = Piece.ATTACKER; // N
          b[CENTER][CENTER + 2] = Piece.ATTACKER;     // E
          // Missing S attacker.
          if (maybeCaptureKing(b, [CENTER, CENTER + 1])) failures.push('king-adj-throne-throne-occupied-still-needs-3A');
        }

        // King on throne: requires 4 attackers (hostile squares alone must not reduce requirement).
        {
          const b = emptyBoard();
          b[CENTER][CENTER] = Piece.KING;
          // Only 3 attackers around.
          b[CENTER - 1][CENTER] = Piece.ATTACKER;
          b[CENTER + 1][CENTER] = Piece.ATTACKER;
          b[CENTER][CENTER - 1] = Piece.ATTACKER;
          if (maybeCaptureKing(b, [CENTER, CENTER])) failures.push('king-on-throne-3A-no-capture');
          // Add 4th attacker => capture.
          b[CENTER][CENTER + 1] = Piece.ATTACKER;
          if (!maybeCaptureKing(b, [CENTER, CENTER])) failures.push('king-on-throne-4A-captures');
        }

        // Full deterministic repro sequence (13 plies): attacker I7→G7 must NOT capture king at F7.
        {
          const parse = (token) => {
            const col = token.charCodeAt(0) - 65;
            const row = SIZE - parseInt(token.slice(1), 10);
            return [row, col];
          };

          const startingBoard = () => {
            const layout = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            const attackers = [
              [0, 3], [0, 4], [0, 5], [0, 6], [0, 7],
              [1, 5],
              [3, 0], [4, 0], [5, 0], [6, 0], [7, 0],
              [5, 1],
              [SIZE - 1, 3], [SIZE - 1, 4], [SIZE - 1, 5], [SIZE - 1, 6], [SIZE - 1, 7],
              [SIZE - 2, 5],
              [3, SIZE - 1], [4, SIZE - 1], [5, SIZE - 1], [6, SIZE - 1], [7, SIZE - 1],
              [5, SIZE - 2]
            ];
            const defenders = [
              [CENTER - 2, CENTER], [CENTER - 1, CENTER],
              [CENTER + 1, CENTER], [CENTER + 2, CENTER],
              [CENTER, CENTER - 2], [CENTER, CENTER - 1],
              [CENTER, CENTER + 1], [CENTER, CENTER + 2],
              [CENTER - 1, CENTER - 1], [CENTER - 1, CENTER + 1],
              [CENTER + 1, CENTER - 1], [CENTER + 1, CENTER + 1]
            ];
            attackers.forEach(([r, c]) => (layout[r][c] = Piece.ATTACKER));
            defenders.forEach(([r, c]) => (layout[r][c] = Piece.DEFENDER));
            layout[CENTER][CENTER] = Piece.KING;
            return layout;
          };

          let b = startingBoard();

          const applyWithCaptures = (board, mv) => {
            const shifted = movePiece(board, mv.from, mv.to);
            return captureEnemyPieces(shifted, mv.to, mv.side);
          };

          const plies = [
            { side: Side.ATTACKERS, from: 'D11', to: 'D10' },
            { side: Side.DEFENDERS, from: 'H6', to: 'H9' },
            { side: Side.ATTACKERS, from: 'H11', to: 'H10' },
            { side: Side.DEFENDERS, from: 'F8', to: 'H8' },
            { side: Side.ATTACKERS, from: 'E11', to: 'E10' },
            { side: Side.DEFENDERS, from: 'G7', to: 'G10' },
            { side: Side.ATTACKERS, from: 'F11', to: 'E11' },
            { side: Side.DEFENDERS, from: 'F7', to: 'I7' },
            { side: Side.ATTACKERS, from: 'F10', to: 'F8' },
            { side: Side.DEFENDERS, from: 'I7', to: 'I10' },
            { side: Side.ATTACKERS, from: 'K7', to: 'I7' },
            { side: Side.DEFENDERS, from: 'F6', to: 'F7' }
          ];

          for (const step of plies) {
            b = simulateMove(b, { side: step.side, from: parse(step.from), to: parse(step.to) });
          }

          const last = { side: Side.ATTACKERS, from: parse('I7'), to: parse('G7') };
          const after = applyWithCaptures(b, last);

          if (after.captured.some(x => x.piece === Piece.KING)) failures.push('alex-ply13-seq-no-king-capture');

          b = after.board;
          const [kr, kc] = parse('F7');
          if (b[kr][kc] !== Piece.KING) failures.push('alex-ply13-seq-king-still-at-F7');
          if (maybeCaptureKing(b, [kr, kc])) failures.push('alex-ply13-seq-maybeCaptureKing-false');
          const win = determineWin(b, { exitFortEnabled: false });
          if (win) failures.push('alex-ply13-seq-no-win');
        }

        return { ok: failures.length === 0, failures };
      }

      self.onmessage = (event) => {
        const data = event.data;
        if (data.type === 'MOVE_REQUEST') {
          try {
            const board = data.board.map(row => row.slice());
            const result = iterativeDeepening(board, data.side, data.settings, data.config);
            self.postMessage({
              type: 'MOVE_RESULT',
              id: data.id,
              payload: result
            });
          } catch (err) {
            self.postMessage({ type: 'MOVE_RESULT', id: data.id, error: err?.message || String(err) });
          }
        } else if (data.type === 'SELF_TEST') {
          try {
            const result = runWorkerSelfTests();
            self.postMessage({ type: 'SELF_TEST_RESULT', id: data.id, payload: result });
          } catch (err) {
            self.postMessage({ type: 'SELF_TEST_RESULT', id: data.id, error: err?.message || String(err) });
          }
        } else if (data.type === 'SELF_PLAY') {
          try {
            const summary = [];
            for (let game = 0; game < data.games; game++) {
              const snapshot = data.initialBoard.map(row => row.slice());
              const result = playSelfGame(
                { moveTimeMs: data.moveTimeMs, maxDepth: data.maxDepth },
                { exitFortEnabled: data.exitFortEnabled, initialBoard: snapshot },
                data.maxPly
              );
              summary.push(result);
            }
            self.postMessage({ type: 'SELF_PLAY_RESULT', id: data.id, payload: summary });
          } catch (err) {
            self.postMessage({ type: 'SELF_PLAY_RESULT', id: data.id, error: err?.message || String(err) });
          }
        }
      };
    })();
  </script>

  <script>
    const SIZE = 11;
    const CENTER = Math.floor(SIZE / 2);
    const Piece = Object.freeze({ EMPTY: '.', ATTACKER: 'A', DEFENDER: 'D', KING: 'K' });
    const Side = Object.freeze({ ATTACKERS: 'attackers', DEFENDERS: 'defenders' });
    const DEFAULT_CONFIG = Object.freeze({ exitFortEnabled: false });
    const STORAGE_KEY = 'hnefataflGameLogs';
    const DifficultyProfiles = Object.freeze({
      casual: { label: 'Casual', moveTimeMs: 200, maxDepth: 3 },
      standard: { label: 'Standard', moveTimeMs: 1000, maxDepth: 8 },
      strong: { label: 'Strong', moveTimeMs: 3000, maxDepth: 32 }
    });

    const restrictedSquares = new Set([
      `${CENTER},${CENTER}`,
      `0,0`, `0,${SIZE - 1}`, `${SIZE - 1},0`, `${SIZE - 1},${SIZE - 1}`
    ]);
    const throneKey = `${CENTER},${CENTER}`;
    const directions = [ [1,0], [-1,0], [0,1], [0,-1] ];

    const boardEl = document.getElementById('board');
    const movesEl = document.getElementById('moves');
    const restartBtn = document.getElementById('restartBtn');
    const sideSelect = document.getElementById('sideSelect');
    const difficultySelect = document.getElementById('difficultySelect');
    const exitFortToggle = document.getElementById('exitFortToggle');
    const statusMessage = document.getElementById('statusMessage');
    const turnBadge = document.getElementById('turnBadge');
    const engineStatusEl = document.getElementById('engineStatus');
    const captureToast = document.getElementById('captureToast');
    const refreshLogsBtn = document.getElementById('refreshLogsBtn');
    const downloadJsonBtn = document.getElementById('downloadJsonBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const clearLogsBtn = document.getElementById('clearLogsBtn');
    const copyBugBtn = document.getElementById('copyBugBtn');
    const logViewer = document.getElementById('logViewer');
    const telemetryNote = document.getElementById('telemetryNote');
    const testStatusEl = document.getElementById('testStatus');
    const selfPlayBtn = document.getElementById('selfPlayBtn');
    const statDepth = document.getElementById('statDepth');
    const statNodes = document.getElementById('statNodes');
    const statEval = document.getElementById('statEval');
    const statTime = document.getElementById('statTime');
    const statPV = document.getElementById('statPV');

    const cellRefs = new Map();
    const piecePool = new Map();
    let captureToastTimeoutId = null;
    let captureFlashTimeoutId = null;
    let storedGames = loadStoredGames();
    let state = {};

    function cloneBoard(board) {
      return board.map(row => row.slice());
    }

    function initialBoard() {
      const layout = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
      const attackers = [
        [0, 3], [0, 4], [0, 5], [0, 6], [0, 7],
        [1, 5],
        [3, 0], [4, 0], [5, 0], [6, 0], [7, 0],
        [5, 1],
        [10, 3], [10, 4], [10, 5], [10, 6], [10, 7],
        [9, 5],
        [3, 10], [4, 10], [5, 10], [6, 10], [7, 10],
        [5, 9]
      ];
      const defenders = [
        [CENTER - 2, CENTER], [CENTER - 1, CENTER],
        [CENTER + 1, CENTER], [CENTER + 2, CENTER],
        [CENTER, CENTER - 2], [CENTER, CENTER - 1],
        [CENTER, CENTER + 1], [CENTER, CENTER + 2],
        [CENTER - 1, CENTER - 1], [CENTER - 1, CENTER + 1],
        [CENTER + 1, CENTER - 1], [CENTER + 1, CENTER + 1]
      ];
      attackers.forEach(([r, c]) => (layout[r][c] = Piece.ATTACKER));
      defenders.forEach(([r, c]) => (layout[r][c] = Piece.DEFENDER));
      layout[CENTER][CENTER] = Piece.KING;
      return layout;
    }

    function createIdBoard(board) {
      let counter = 0;
      return board.map(row => row.map(cell => (cell === Piece.EMPTY ? null : `piece-${counter++}`)));
    }

    function coordKey(r, c) {
      return `${r},${c}`;
    }

    function isInside(r, c) {
      return r >= 0 && c >= 0 && r < SIZE && c < SIZE;
    }

    function isRestricted(r, c) {
      return restrictedSquares.has(coordKey(r, c));
    }

    function isCorner(r, c) {
      return (r === 0 || r === SIZE - 1) && (c === 0 || c === SIZE - 1);
    }

    function pieceBelongsTo(piece, side) {
      if (piece === Piece.EMPTY) return false;
      if (side === Side.ATTACKERS) return piece === Piece.ATTACKER;
      return piece === Piece.DEFENDER || piece === Piece.KING;
    }

    function opposite(side) {
      return side === Side.ATTACKERS ? Side.DEFENDERS : Side.ATTACKERS;
    }

    function isHostileSquareAgainst(side, r, c, board) {
      const key = coordKey(r, c);
      if (key === throneKey) {
        if (side === Side.ATTACKERS) return true;
        return board[r][c] === Piece.EMPTY;
      }
      if (isCorner(r, c)) {
        return board[r][c] === Piece.EMPTY || !pieceBelongsTo(board[r][c], side);
      }
      return false;
    }

    function getLegalMoves(board, r, c, side) {
      const piece = board[r][c];
      if (!pieceBelongsTo(piece, side)) return [];
      const moves = [];
      for (const [dr, dc] of directions) {
        let nr = r + dr;
        let nc = c + dc;
        while (isInside(nr, nc) && board[nr][nc] === Piece.EMPTY) {
          if (isRestricted(nr, nc) && piece !== Piece.KING) {
            if (coordKey(nr, nc) === throneKey) {
              nr += dr;
              nc += dc;
              continue;
            }
            break;
          }
          moves.push([nr, nc]);
          nr += dr;
          nc += dc;
        }
      }
      return moves;
    }

    function movePiece(board, from, to) {
      const newBoard = cloneBoard(board);
      const [fr, fc] = from;
      const [tr, tc] = to;
      newBoard[tr][tc] = newBoard[fr][fc];
      newBoard[fr][fc] = Piece.EMPTY;
      return newBoard;
    }

    function captureEnemyPieces(board, movedTo, moverSide) {
      const newBoard = cloneBoard(board);
      const opponent = opposite(moverSide);
      const captured = [];
      for (const [dr, dc] of directions) {
        const adjR = movedTo[0] + dr;
        const adjC = movedTo[1] + dc;
        if (!isInside(adjR, adjC)) continue;
        const adjPiece = newBoard[adjR][adjC];
        if (!pieceBelongsTo(adjPiece, opponent)) continue;
        if (adjPiece === Piece.KING) {
          if (maybeCaptureKing(newBoard, [adjR, adjC])) {
            newBoard[adjR][adjC] = Piece.EMPTY;
            captured.push({ r: adjR, c: adjC, piece: Piece.KING });
          }
          continue;
        }
        const beyondR = adjR + dr;
        const beyondC = adjC + dc;
        const beyondHostile =
          (isInside(beyondR, beyondC) && pieceBelongsTo(newBoard[beyondR][beyondC], moverSide)) ||
          (isInside(beyondR, beyondC) && isHostileSquareAgainst(opponent, beyondR, beyondC, newBoard));
        if (beyondHostile) {
          newBoard[adjR][adjC] = Piece.EMPTY;
          captured.push({ r: adjR, c: adjC, piece: adjPiece });
        }
      }
      const shieldCaptures = applyShieldwall(newBoard, moverSide);
      return { board: newBoard, captured: [...captured, ...shieldCaptures] };
    }

    function maybeCaptureKing(board, pos) {
      const [r, c] = pos;
      if (r === 0 || r === SIZE - 1 || c === 0 || c === SIZE - 1) {
        return false;
      }

      const onThrone = coordKey(r, c) === throneKey;
      const adjacentToThrone = Math.abs(r - CENTER) + Math.abs(c - CENTER) === 1;

      // Copenhagen nuance (bugfix): when the king is adjacent to the throne,
      // the throne itself does NOT count as the 3rd capturing side if empty.
      // We require THREE attackers on the three non-throne sides.
      if (adjacentToThrone && !onThrone) {
        // The throne side never counts toward capturing the king, even if empty.
        // Capture requires attackers on ALL three non-throne adjacent squares.
        const nonThroneAdj = [];
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) continue;
          if (coordKey(nr, nc) === throneKey) continue;
          nonThroneAdj.push([nr, nc]);
        }
        return nonThroneAdj.length === 3 && nonThroneAdj.every(([nr, nc]) => board[nr][nc] === Piece.ATTACKER);
      }

      // Default: king capture requires 4 hostile sides.
      // Hostile sides include attackers, corners, and (for non-adjacent cases) an empty throne.
      let hostileCount = 0;
      for (const [dr, dc] of directions) {
        const nr = r + dr;
        const nc = c + dc;
        if (!isInside(nr, nc)) continue;
        const occupant = board[nr][nc];
        if (occupant === Piece.ATTACKER) {
          hostileCount += 1;
          continue;
        }
        if (isHostileSquareAgainst(Side.DEFENDERS, nr, nc, board)) {
          hostileCount += 1;
        }
      }
      const required = 4; // including on-throne (Copenhagen)
      return hostileCount >= required;
    }

    function applyShieldwall(board, moverSide) {
      const opponent = opposite(moverSide);
      const captured = [];
      const bracketSatisfied = (row, col) => {
        if (!isInside(row, col)) return false;
        if (isCorner(row, col)) return true;
        return pieceBelongsTo(board[row][col], moverSide);
      };
      const scanHorizontal = (edgeRow) => {
        const innerRow = edgeRow === 0 ? 1 : SIZE - 2;
        let col = 0;
        while (col < SIZE) {
          if (!pieceBelongsTo(board[edgeRow][col], opponent)) {
            col += 1;
            continue;
          }
          const start = col;
          while (col < SIZE && pieceBelongsTo(board[edgeRow][col], opponent)) {
            col += 1;
          }
          const end = col - 1;
          if (end - start + 1 < 2) continue;
          const leftIdx = start - 1;
          const rightIdx = end + 1;
          const touchesLeftCorner = start === 0 && isCorner(edgeRow, 0);
          const touchesRightCorner = end === SIZE - 1 && isCorner(edgeRow, SIZE - 1);
          const leftOk = touchesLeftCorner || (leftIdx >= 0 && bracketSatisfied(edgeRow, leftIdx));
          const rightOk = touchesRightCorner || (rightIdx < SIZE && bracketSatisfied(edgeRow, rightIdx));
          if (!leftOk || !rightOk) continue;
          let support = true;
          for (let c = start; c <= end; c++) {
            if (!pieceBelongsTo(board[innerRow][c], moverSide)) {
              support = false;
              break;
            }
          }
          if (!support) continue;
          for (let c = start; c <= end; c++) {
            if (board[edgeRow][c] === Piece.KING) continue;
            captured.push({ r: edgeRow, c, piece: board[edgeRow][c] });
            board[edgeRow][c] = Piece.EMPTY;
          }
        }
      };
      const scanVertical = (edgeCol) => {
        const innerCol = edgeCol === 0 ? 1 : SIZE - 2;
        let row = 0;
        while (row < SIZE) {
          if (!pieceBelongsTo(board[row][edgeCol], opponent)) {
            row += 1;
            continue;
          }
          const start = row;
          while (row < SIZE && pieceBelongsTo(board[row][edgeCol], opponent)) {
            row += 1;
          }
          const end = row - 1;
          if (end - start + 1 < 2) continue;
          const topIdx = start - 1;
          const bottomIdx = end + 1;
          const touchesTopCorner = start === 0 && isCorner(0, edgeCol);
          const touchesBottomCorner = end === SIZE - 1 && isCorner(SIZE - 1, edgeCol);
          const topOk = touchesTopCorner || (topIdx >= 0 && bracketSatisfied(topIdx, edgeCol));
          const bottomOk = touchesBottomCorner || (bottomIdx < SIZE && bracketSatisfied(bottomIdx, edgeCol));
          if (!topOk || !bottomOk) continue;
          let support = true;
          for (let rIndex = start; rIndex <= end; rIndex++) {
            if (!pieceBelongsTo(board[rIndex][innerCol], moverSide)) {
              support = false;
              break;
            }
          }
          if (!support) continue;
          for (let rIndex = start; rIndex <= end; rIndex++) {
            if (board[rIndex][edgeCol] === Piece.KING) continue;
            captured.push({ r: rIndex, c: edgeCol, piece: board[rIndex][edgeCol] });
            board[rIndex][edgeCol] = Piece.EMPTY;
          }
        }
      };
      scanHorizontal(0);
      scanHorizontal(SIZE - 1);
      scanVertical(0);
      scanVertical(SIZE - 1);
      return captured;
    }

    function hasLegalMove(board, side) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (pieceBelongsTo(board[r][c], side) && getLegalMoves(board, r, c, side).length) {
            return true;
          }
        }
      }
      return false;
    }

    function locateKing(board) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === Piece.KING) return [r, c];
        }
      }
      return null;
    }

    function defendersEncircled(board) {
      const kingPos = locateKing(board);
      if (!kingPos) return true;
      const visited = new Set();
      const queue = [kingPos];
      visited.add(coordKey(...kingPos));
      while (queue.length) {
        const [r, c] = queue.shift();
        if (r === 0 || c === 0 || r === SIZE - 1 || c === SIZE - 1) {
          return false;
        }
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) continue;
          const key = coordKey(nr, nc);
          if (visited.has(key)) continue;
          const cell = board[nr][nc];
          if (cell === Piece.EMPTY || pieceBelongsTo(cell, Side.DEFENDERS)) {
            visited.add(key);
            queue.push([nr, nc]);
          }
        }
      }
      return true;
    }

    function attackersCanCaptureKing(board) {
      const attackersMoves = allMoves(board, Side.ATTACKERS);
      for (const mv of attackersMoves) {
        const next = simulateMove(board, mv);
        if (!locateKing(next)) {
          return true;
        }
      }
      return false;
    }

    function defendersExitFort(board) {
      const kingPos = locateKing(board);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      const onEdge = kr === 0 || kc === 0 || kr === SIZE - 1 || kc === SIZE - 1;
      if (!onEdge) return false;
      const kingMoves = getLegalMoves(board, kr, kc, Side.DEFENDERS);
      if (!kingMoves.length) return false;
      return !attackersCanCaptureKing(board);
    }

    function allMoves(board, side) {
      const moves = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!pieceBelongsTo(board[r][c], side)) continue;
          const legal = getLegalMoves(board, r, c, side);
          for (const [nr, nc] of legal) {
            moves.push({ side, from: [r, c], to: [nr, nc] });
          }
        }
      }
      return moves;
    }

    function determineWin(board, config = DEFAULT_CONFIG) {
      const kingPos = locateKing(board);
      if (!kingPos) {
        return { winner: Side.ATTACKERS, reason: 'King captured • attackers win' };
      }
      if (isCorner(...kingPos)) {
        return { winner: Side.DEFENDERS, reason: 'King reached a corner • defenders win' };
      }
      if (config.exitFortEnabled && defendersExitFort(board)) {
        return { winner: Side.DEFENDERS, reason: 'Exit fort established • defenders win' };
      }
      if (defendersEncircled(board)) {
        return { winner: Side.ATTACKERS, reason: 'Defenders encircled • attackers win' };
      }
      if (!hasLegalMove(board, Side.ATTACKERS)) {
        return { winner: Side.DEFENDERS, reason: 'Attackers have no legal moves' };
      }
      if (!hasLegalMove(board, Side.DEFENDERS)) {
        return { winner: Side.ATTACKERS, reason: 'Defenders have no legal moves' };
      }
      return null;
    }

    function simulateMove(board, move) {
      const shifted = movePiece(board, move.from, move.to);
      const result = captureEnemyPieces(shifted, move.to, move.side);
      return result.board;
    }

    function repetitionKey(board) {
      return board.map(row => row.join('')).join('|');
    }

    function repetitionLoser(historyKeys, repeatingSide) {
      // Copenhagen variant implemented here: defenders lose on 3x repetition.
      // We keep this as a small pure function so it can be unit-tested.
      if (repeatingSide !== Side.DEFENDERS) return null;
      if (!Array.isArray(historyKeys) || historyKeys.length < 3) return null;
      const current = historyKeys[historyKeys.length - 1];
      const count = historyKeys.reduce((acc, key) => acc + (key === current ? 1 : 0), 0);
      return count >= 3 ? Side.DEFENDERS : null;
    }

    function notation([r, c]) {
      return String.fromCharCode(65 + c) + (SIZE - r);
    }

    function parseNotation(token) {
      const col = token.charCodeAt(0) - 65;
      const row = SIZE - parseInt(token.slice(1), 10);
      return [row, col];
    }

    function encodeBoard(board) {
      return board.map(row => row.join('')).join('/');
    }

    function updateStatus(text, side) {
      statusMessage.textContent = text;
      turnBadge.textContent = side.charAt(0).toUpperCase() + side.slice(1);
      turnBadge.className = `badge ${side}`;
    }

    function setupBoardGrid() {
      boardEl.innerHTML = '';
      cellRefs.clear();
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cellBtn = document.createElement('button');
          cellBtn.type = 'button';
          const special = isCorner(r, c) || coordKey(r, c) === throneKey;
          cellBtn.className = `cell ${special ? 'cell-special' : 'cell-bright'}`;
          cellBtn.dataset.row = r;
          cellBtn.dataset.col = c;
          cellBtn.setAttribute('aria-label', `Square ${notation([r, c])}`);
          cellBtn.addEventListener('click', () => onCellClick(r, c));
          boardEl.appendChild(cellBtn);
          cellRefs.set(coordKey(r, c), cellBtn);
        }
      }
    }

    function capturePiecePositions() {
      const positions = new Map();
      piecePool.forEach((el, id) => {
        positions.set(id, el.getBoundingClientRect());
      });
      return positions;
    }

    function renderBoard(prevPositions = null) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const key = coordKey(r, c);
          const cellBtn = cellRefs.get(key);
          if (!cellBtn) continue;
          const isLegal = state.legalTargets.has(key) && state.board[r][c] === Piece.EMPTY;
          cellBtn.classList.toggle('legal-move', isLegal);
          cellBtn.classList.toggle('selected', state.highlight && key === coordKey(...state.highlight));
          cellBtn.classList.toggle('last-move-from', state.lastMove && key === coordKey(...state.lastMove.from));
          cellBtn.classList.toggle('last-move-to', state.lastMove && key === coordKey(...state.lastMove.to));
          cellBtn.classList.toggle('capture-flash', state.captureFlash.has(key));
          const piece = state.board[r][c];
          const pieceId = state.idBoard?.[r]?.[c] ?? null;
          let pieceEl = pieceId ? piecePool.get(pieceId) : null;
          if (piece === Piece.EMPTY || !pieceId) {
            if (pieceEl) {
              pieceEl.remove();
              piecePool.delete(pieceId);
            }
            continue;
          }
          if (!pieceEl) {
            pieceEl = document.createElement('div');
            pieceEl.className = 'piece';
            pieceEl.dataset.pieceId = pieceId;
            piecePool.set(pieceId, pieceEl);
          }
          pieceEl.className = 'piece';
          if (piece === Piece.ATTACKER) {
            pieceEl.classList.add('attacker');
            pieceEl.textContent = '';
          } else if (piece === Piece.DEFENDER) {
            pieceEl.classList.add('defender');
            pieceEl.textContent = '';
          } else {
            pieceEl.classList.add('king');
            pieceEl.textContent = '♔';
          }
          if (pieceEl.parentElement !== cellBtn) {
            cellBtn.appendChild(pieceEl);
          }
          if (prevPositions && prevPositions.has(pieceId)) {
            const prev = prevPositions.get(pieceId);
            const next = pieceEl.getBoundingClientRect();
            const dx = prev.left - next.left;
            const dy = prev.top - next.top;
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
              pieceEl.animate([
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0, 0)' }
              ], {
                duration: 320,
                easing: 'cubic-bezier(0.22, 1, 0.36, 1)'
              });
            }
          }
        }
      }
    }

    function renderMoves() {
      movesEl.innerHTML = '';
      state.moveHistory.forEach((entry, idx) => {
        const row = document.createElement('div');
        row.className = 'move-row';
        const idxEl = document.createElement('span');
        idxEl.className = 'move-index';
        idxEl.textContent = idx + 1;
        const textEl = document.createElement('div');
        textEl.className = 'move-text';
        const sideEl = document.createElement('span');
        sideEl.className = 'move-side';
        sideEl.textContent = entry.side;
        const descEl = document.createElement('span');
        descEl.className = 'move-description';
        const captureSuffix = entry.captureSummary ? ` (${entry.captureSummary})` : '';
        descEl.textContent = `${notation(entry.from)} → ${notation(entry.to)}${captureSuffix}`;
        textEl.append(sideEl, descEl);
        row.append(idxEl, textEl);
        movesEl.appendChild(row);
      });
      movesEl.scrollTop = movesEl.scrollHeight;
    }

    function setHighlight(from, legal) {
      state.highlight = from;
      state.legalTargets = new Set(legal.map(([r, c]) => coordKey(r, c)));
    }

    function clearHighlight() {
      state.highlight = null;
      state.legalTargets = new Set();
    }

    function isPlayerTurn() {
      return state.currentSide === state.playerSide && !state.gameOver;
    }

    function onCellClick(r, c) {
      if (!isPlayerTurn()) return;
      const key = coordKey(r, c);
      if (state.highlight && state.legalTargets.has(key)) {
        playerCommitMove([r, c]);
        return;
      }
      const piece = state.board[r][c];
      if (pieceBelongsTo(piece, state.playerSide)) {
        const legal = getLegalMoves(state.board, r, c, state.playerSide);
        setHighlight([r, c], legal);
        renderBoard();
      }
    }

    function playerCommitMove([tr, tc]) {
      const from = state.highlight;
      if (!from) return;
      executeMove({ from, to: [tr, tc], side: state.playerSide });
    }

    function showCaptureToast(captured) {
      if (captureToastTimeoutId) clearTimeout(captureToastTimeoutId);
      if (!captured.length) {
        captureToast.classList.remove('visible');
        captureToast.textContent = '';
        return;
      }
      const counts = captured.reduce((acc, entry) => {
        acc[entry.piece] = (acc[entry.piece] || 0) + 1;
        return acc;
      }, {});
      const parts = [];
      if (counts[Piece.ATTACKER]) parts.push(`${counts[Piece.ATTACKER]} attacker${counts[Piece.ATTACKER] > 1 ? 's' : ''}`);
      if (counts[Piece.DEFENDER]) parts.push(`${counts[Piece.DEFENDER]} defender${counts[Piece.DEFENDER] > 1 ? 's' : ''}`);
      if (counts[Piece.KING]) parts.push('the king');
      captureToast.textContent = `Captured ${parts.join(' & ')}`;
      captureToast.classList.add('visible');
      captureToastTimeoutId = setTimeout(() => {
        captureToast.classList.remove('visible');
      }, 2200);
    }

    function setCaptureFlash(captured) {
      if (captureFlashTimeoutId) clearTimeout(captureFlashTimeoutId);
      state.captureFlash = new Set(captured.map(cap => coordKey(cap.r, cap.c)));
      if (!state.captureFlash.size) return;
      captureFlashTimeoutId = setTimeout(() => {
        state.captureFlash.clear();
        renderBoard();
      }, 900);
    }

    function executeMove(move) {
      const { from, to, side } = move;
      const prevPositions = capturePiecePositions();
      const [fr, fc] = from;
      const [tr, tc] = to;
      const movingId = state.idBoard[fr][fc];
      const movedBoard = movePiece(state.board, from, to);
      state.idBoard[fr][fc] = null;
      state.idBoard[tr][tc] = movingId;

      // Instrumentation: if a move evaluates a potential king capture, log the geometry.
      const kingCaptureChecks = [];
      for (const [dr, dc] of directions) {
        const adjR = tr + dr;
        const adjC = tc + dc;
        if (!isInside(adjR, adjC)) continue;
        if (movedBoard[adjR][adjC] !== Piece.KING) continue;

        const kr = adjR;
        const kc = adjC;
        const adjacentToThrone = Math.abs(kr - CENTER) + Math.abs(kc - CENTER) === 1;
        const fmt = (cell) => (cell === Piece.EMPTY ? 'empty' : cell);
        const N = isInside(kr - 1, kc) ? `${fmt(movedBoard[kr - 1][kc])}${coordKey(kr - 1, kc) === throneKey ? '(throne)' : ''}` : 'offboard';
        const S = isInside(kr + 1, kc) ? `${fmt(movedBoard[kr + 1][kc])}${coordKey(kr + 1, kc) === throneKey ? '(throne)' : ''}` : 'offboard';
        const W = isInside(kr, kc - 1) ? `${fmt(movedBoard[kr][kc - 1])}${coordKey(kr, kc - 1) === throneKey ? '(throne)' : ''}` : 'offboard';
        const E = isInside(kr, kc + 1) ? `${fmt(movedBoard[kr][kc + 1])}${coordKey(kr, kc + 1) === throneKey ? '(throne)' : ''}` : 'offboard';

        let nonThroneA = null;
        if (adjacentToThrone) {
          const candidates = [
            [kr - 1, kc],
            [kr + 1, kc],
            [kr, kc - 1],
            [kr, kc + 1]
          ].filter(([r, c]) => isInside(r, c) && coordKey(r, c) !== throneKey);
          nonThroneA = candidates.filter(([r, c]) => movedBoard[r][c] === Piece.ATTACKER).length;
        }

        kingCaptureChecks.push({
          king: notation([kr, kc]),
          adjacentToThrone,
          nonThroneAttackers: nonThroneA,
          capture: maybeCaptureKing(movedBoard, [kr, kc]),
          N, S, W, E
        });
      }

      const { board: afterCapture, captured } = captureEnemyPieces(movedBoard, to, side);
      captured.forEach(cap => {
        const capId = state.idBoard[cap.r][cap.c];
        if (capId) {
          const el = piecePool.get(capId);
          if (el) el.remove();
          piecePool.delete(capId);
        }
        state.idBoard[cap.r][cap.c] = null;
      });
      state.board = afterCapture;
      state.lastMove = { from, to };
      clearHighlight();
      setCaptureFlash(captured);
      const repKey = repetitionKey(state.board);
      state.historyKeys.push(repKey);
      const captureSummary = captured.length ? `${captured.length} captured` : '';
      state.moveHistory.push({
        ...move,
        captureSummary,
        kingCaptureChecks,
        capturedPieces: captured.map(entry => ({ piece: entry.piece, location: notation([entry.r, entry.c]) }))
      });
      renderBoard(prevPositions);
      renderMoves();
      showCaptureToast(captured);
      const loser = repetitionLoser(state.historyKeys, side);
      if (loser) {
        endGame(opposite(loser), `Perpetual repetition by ${loser}`);
        return;
      }
      const winResult = determineWin(state.board, state.config);
      if (winResult) {
        endGame(winResult.winner, winResult.reason);
        return;
      }
      state.currentSide = opposite(state.currentSide);
      updateStatus(`${state.currentSide.charAt(0).toUpperCase() + state.currentSide.slice(1)} to move`, state.currentSide);
      if (state.currentSide !== state.playerSide) {
        requestAIMove();
      }
    }

    function randomChoice(arr) {
      const rand = state.rng ? state.rng() : Math.random();
      return arr[Math.floor(rand * arr.length)];
    }

    function createRng(seed) {
      let t = seed >>> 0;
      return () => {
        t += 0x6d2b79f5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function rngSeed() {
      if (window.crypto?.getRandomValues) {
        const buf = new Uint32Array(1);
        window.crypto.getRandomValues(buf);
        return buf[0] >>> 0;
      }
      return Math.floor(Math.random() * 0xffffffff);
    }

    function endGame(winner, reason) {
      if (state.gameOver) return;
      state.gameOver = true;
      engineManager.cancelCurrent();
      engineStatusEl.textContent = 'Idle';
      updateStatus(`${winner} win · ${reason}`, winner);
      finalizeGameLog(winner, reason);
    }

    function restartGame() {
      piecePool.forEach(el => el.remove());
      piecePool.clear();
      if (captureToastTimeoutId) clearTimeout(captureToastTimeoutId);
      if (captureFlashTimeoutId) clearTimeout(captureFlashTimeoutId);
      captureToast.classList.remove('visible');
      captureToast.textContent = '';
      engineManager.cancelCurrent();
      const board = initialBoard();
      const config = { exitFortEnabled: !!exitFortToggle.checked };
      const seed = rngSeed();
      state = {
        board,
        idBoard: createIdBoard(board),
        currentSide: Side.ATTACKERS,
        playerSide: sideSelect.value,
        highlight: null,
        legalTargets: new Set(),
        lastMove: null,
        moveHistory: [],
        historyKeys: [],
        gameOver: false,
        captureFlash: new Set(),
        config,
        rng: createRng(seed),
        gameMeta: {
          id: crypto.randomUUID ? crypto.randomUUID() : `game-${Date.now()}-${Math.random().toString(16).slice(2)}`,
          seed,
          startedAt: new Date().toISOString(),
          playerSide: sideSelect.value,
          exitFortEnabled: config.exitFortEnabled
        },
        engineToken: 0
      };
      resetEngineStats();
      engineStatusEl.textContent = 'Idle';
      state.historyKeys.push(repetitionKey(state.board));
      updateStatus('Attackers to move', Side.ATTACKERS);
      renderBoard();
      renderMoves();
      if (state.playerSide !== state.currentSide) {
        requestAIMove();
      }
    }

    function finalizeGameLog(winner, reason) {
      if (!state.gameMeta) return;
      const entry = {
        id: state.gameMeta.id,
        startedAt: state.gameMeta.startedAt,
        finishedAt: new Date().toISOString(),
        seed: state.gameMeta.seed,
        playerSide: state.gameMeta.playerSide,
        exitFortEnabled: state.gameMeta.exitFortEnabled,
        winner,
        reason,
        board: encodeBoard(state.board),
        moveCount: state.moveHistory.length,
        moves: state.moveHistory.map(move => ({
          side: move.side,
          from: notation(move.from),
          to: notation(move.to),
          captured: move.capturedPieces
        }))
      };
      storedGames.push(entry);
      persistStoredGames(storedGames);
      refreshLogViewer();
      state.gameMeta = null;
    }

    function loadStoredGames() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        return raw
          .split('\n')
          .map(line => line.trim())
          .filter(Boolean)
          .map(line => JSON.parse(line));
      } catch (err) {
        console.warn('Unable to load stored games', err);
        return [];
      }
    }

    function persistStoredGames(games) {
      try {
        const payload = games.map(entry => JSON.stringify(entry)).join('\n');
        localStorage.setItem(STORAGE_KEY, payload);
      } catch (err) {
        console.warn('Unable to persist logs', err);
      }
    }

    function refreshLogViewer() {
      if (!storedGames.length) {
        logViewer.value = '';
        telemetryNote.textContent = 'No game logs yet.';
        return;
      }
      logViewer.value = storedGames.map(entry => JSON.stringify(entry)).join('\n');
      telemetryNote.textContent = `${storedGames.length} logged game${storedGames.length === 1 ? '' : 's'} stored locally.`;
    }

    function downloadFile(content, filename, type = 'application/json') {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function toCsv(games) {
      const header = ['id', 'startedAt', 'finishedAt', 'seed', 'playerSide', 'exitFortEnabled', 'winner', 'reason', 'moveCount'];
      const rows = games.map(entry => {
        const values = header.map(key => entry[key]);
        return values.map(value => {
          if (value == null) return '';
          const str = String(value).replace(/"/g, '""');
          return `"${str}"`;
        }).join(',');
      });
      return [header.join(','), ...rows].join('\n');
    }

    function copyBugReport() {
      const boardState = encodeBoard(state.board);

      const moves = state.moveHistory
        .map((move, idx) => {
          const caps = (move.capturedPieces && move.capturedPieces.length)
            ? ` [captured: ${move.capturedPieces.map(c => `${c.piece}@${c.location}`).join(', ')}]`
            : '';

          const kingChecks = (move.kingCaptureChecks && move.kingCaptureChecks.length)
            ? ` [king-capture-check: ${move.kingCaptureChecks.map(k => {
              const adj = k.adjacentToThrone ? ` adjThrone nonThroneA=${k.nonThroneAttackers}/3` : '';
              return `${k.king} capture=${k.capture ? 'YES' : 'no'}${adj} (N=${k.N},E=${k.E},W=${k.W},S=${k.S})`;
            }).join(' | ')}]`
            : '';

          return `${idx + 1}. ${move.side}: ${notation(move.from)}→${notation(move.to)}${move.captureSummary ? ' ' + move.captureSummary : ''}${caps}${kingChecks}`;
        })
        .join('\n');

      const findKing = () => {
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (state.board[r][c] === Piece.KING) return [r, c];
          }
        }
        return null;
      };

      const kingPos = findKing();
      const lastMove = state.moveHistory[state.moveHistory.length - 1];
      const lastKingCapture = lastMove?.capturedPieces?.find(c => c.piece === Piece.KING);

      const kingLine = kingPos
        ? `King: ${notation(kingPos)} (alive)`
        : (lastKingCapture ? `King: captured at ${lastKingCapture.location}` : 'King: not found');

      const adjSnapshot = (() => {
        const pos = kingPos || (lastKingCapture ? parseNotation(lastKingCapture.location) : null);
        if (!pos) return null;
        const [r, c] = pos;
        const dirs = [
          ['N', -1, 0],
          ['S', 1, 0],
          ['W', 0, -1],
          ['E', 0, 1]
        ];
        const fmt = (cell) => {
          if (cell === Piece.EMPTY) return 'empty';
          if (cell === Piece.ATTACKER) return 'A';
          if (cell === Piece.DEFENDER) return 'D';
          if (cell === Piece.KING) return 'K';
          return String(cell);
        };

        const parts = [];
        for (const [label, dr, dc] of dirs) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) {
            parts.push(`${label}=offboard`);
            continue;
          }
          const special = (coordKey(nr, nc) === throneKey) ? ' (throne)' : (isCorner(nr, nc) ? ' (corner)' : '');
          parts.push(`${label}=${fmt(state.board[nr][nc])}${special}`);
        }

        const kingAdj = `King adjacency: ${parts.join(', ')}`;

        // Extra capture-rule context (Copenhagen nuance): if king is adjacent to the throne,
        // capture requires 3 attackers on the 3 non-throne sides.
        const adjacentToThrone = Math.abs(r - CENTER) + Math.abs(c - CENTER) === 1;
        if (!adjacentToThrone) return kingAdj;

        const nonThrone = [];
        for (const [label, dr, dc] of dirs) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) continue;
          if (coordKey(nr, nc) === throneKey) continue;
          nonThrone.push({ label, r: nr, c: nc, cell: state.board[nr][nc] });
        }
        const attackers = nonThrone.filter(x => x.cell === Piece.ATTACKER);
        const detail = nonThrone.map(x => `${x.label}=${fmt(x.cell)}`).join(', ');
        const ruleLine = `Adj-to-throne capture check: attackers on non-throne sides = ${attackers.length}/3 (${detail})`;

        return `${kingAdj}\n${ruleLine}`;
      })();

      const report = [
        'Hnefatafl bug report',
        `Timestamp: ${new Date().toISOString()}`,
        `Player side: ${state.playerSide}`,
        `Exit Fort enabled: ${state.config.exitFortEnabled}`,
        `Seed: ${state.gameMeta?.seed ?? 'n/a'}`,
        kingLine,
        adjSnapshot,
        `Board: ${boardState}`,
        'Moves:',
        moves || 'No moves yet.'
      ].filter(Boolean).join('\n');

      if (navigator.clipboard?.writeText) {
        navigator.clipboard.writeText(report).then(() => {
          telemetryNote.textContent = 'Bug report copied to clipboard.';
        }).catch(() => fallbackCopy(report));
      } else {
        fallbackCopy(report);
      }
    }

    function fallbackCopy(text) {
      const area = document.createElement('textarea');
      area.value = text;
      document.body.appendChild(area);
      area.select();
      document.execCommand('copy');
      document.body.removeChild(area);
      telemetryNote.textContent = 'Bug report copied (fallback).';
    }

    function clearLogs() {
      storedGames = [];
      persistStoredGames(storedGames);
      refreshLogViewer();
      telemetryNote.textContent = 'Logs cleared.';
    }

    function regressionScenarios() {
      const scenarioAlex = [
        { side: Side.ATTACKERS, from: 'A8', to: 'B8' },
        { side: Side.DEFENDERS, from: 'H6', to: 'H3' },
        { side: Side.ATTACKERS, from: 'H11', to: 'H4' },
        { side: Side.DEFENDERS, from: 'G5', to: 'H5' },
        { side: Side.ATTACKERS, from: 'A4', to: 'A3' },
        { side: Side.DEFENDERS, from: 'G6', to: 'I6' },
        { side: Side.ATTACKERS, from: 'K4', to: 'I4' },
        { side: Side.DEFENDERS, from: 'F6', to: 'H6' },
        { side: Side.ATTACKERS, from: 'G11', to: 'G8' },
        { side: Side.DEFENDERS, from: 'H6', to: 'H11' }
      ];

      return [
        {
          name: 'Exit Fort disabled prevents false win (Alex repro)',
          run: () => {
            let board = initialBoard();
            for (const step of scenarioAlex) {
              const move = { side: step.side, from: parseNotation(step.from), to: parseNotation(step.to) };
              board = simulateMove(board, move);
              const win = determineWin(board, { exitFortEnabled: false });
              if (win) return false;
            }
            return true;
          }
        },
        {
          name: 'Corner escape recognized (king already in corner)',
          run: () => {
            const board = initialBoard();
            // Minimal deterministic setup: king on a corner should immediately win.
            board[CENTER][CENTER] = Piece.EMPTY;
            board[0][0] = Piece.KING;
            const result = determineWin(board, { exitFortEnabled: false });
            return result?.winner === Side.DEFENDERS;
          }
        },
        {
          name: 'Restricted squares block non-king movement (corner + throne)',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));

            // Corner restriction: a non-king piece with a clear file to a corner cannot land on it.
            board[0][3] = Piece.ATTACKER;
            const legalCorner = getLegalMoves(board, 0, 3, Side.ATTACKERS)
              .map(([r, c]) => coordKey(r, c));
            if (legalCorner.includes(coordKey(0, 0))) return false;

            // Throne restriction: a non-king piece cannot land on the throne, but can move past it.
            board[CENTER][CENTER - 3] = Piece.ATTACKER;
            const legalThrone = getLegalMoves(board, CENTER, CENTER - 3, Side.ATTACKERS)
              .map(([r, c]) => coordKey(r, c));
            if (legalThrone.includes(coordKey(CENTER, CENTER))) return false;
            if (!legalThrone.includes(coordKey(CENTER, CENTER + 1))) return false;

            return true;
          }
        },
        {
          name: 'Standard capture: sandwich defender between attackers',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            // Setup: D at (5,5), A at (5,6); move A from (5,3)->(5,4) to capture D.
            board[5][3] = Piece.ATTACKER;
            board[5][6] = Piece.ATTACKER;
            board[5][5] = Piece.DEFENDER;
            const after = simulateMove(board, { side: Side.ATTACKERS, from: [5, 3], to: [5, 4] });
            return after[5][5] === Piece.EMPTY;
          }
        },
        {
          name: 'Shieldwall capture on edge (2+ pieces, bracketed + supported)',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            // Top edge defenders at (0,1)-(0,2).
            board[0][1] = Piece.DEFENDER;
            board[0][2] = Piece.DEFENDER;
            // Bracket: left corner counts as bracket; right bracket is attacker at (0,3).
            board[0][3] = Piece.ATTACKER;
            // Support from inside row (row 1): attackers behind the edge segment.
            board[1][1] = Piece.ATTACKER;
            board[1][2] = Piece.ATTACKER;
            // Trigger shieldwall with any legal attacker move that doesn't disturb the setup.
            board[5][4] = Piece.ATTACKER;
            const after = simulateMove(board, { side: Side.ATTACKERS, from: [5, 4], to: [5, 5] });
            return after[0][1] === Piece.EMPTY && after[0][2] === Piece.EMPTY;
          }
        },
        {
          name: 'Shieldwall does not capture the king',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            // King on top edge as part of a would-be shieldwall segment.
            board[0][1] = Piece.KING;
            board[0][2] = Piece.DEFENDER;
            // Bracket and support setup.
            board[0][3] = Piece.ATTACKER;
            board[1][1] = Piece.ATTACKER;
            board[1][2] = Piece.ATTACKER;
            // Trigger.
            board[5][4] = Piece.ATTACKER;
            const after = simulateMove(board, { side: Side.ATTACKERS, from: [5, 4], to: [5, 5] });
            // King must remain on board.
            return after[0][1] === Piece.KING;
          }
        },
        {
          name: 'King capture adjacent to throne requires 3 attackers on non-throne sides',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            // King adjacent to throne at (CENTER, CENTER+1).
            board[CENTER][CENTER + 1] = Piece.KING;
            // Three attackers on the three non-throne sides.
            board[CENTER - 1][CENTER + 1] = Piece.ATTACKER;
            board[CENTER + 1][CENTER + 1] = Piece.ATTACKER;
            board[CENTER][CENTER + 2] = Piece.ATTACKER;
            // Trigger capture evaluation.
            board[5][4] = Piece.ATTACKER;
            const after = simulateMove(board, { side: Side.ATTACKERS, from: [5, 4], to: [5, 5] });
            if (after[CENTER][CENTER + 1] !== Piece.EMPTY) return false;
            const win = determineWin(after, { exitFortEnabled: false });
            return win?.winner === Side.ATTACKERS;
          }
        },
        {
          name: 'King NOT captured adjacent to throne with only 2 attackers (empty throne does not count)',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            board[CENTER][CENTER + 1] = Piece.KING;
            board[CENTER - 1][CENTER + 1] = Piece.ATTACKER;
            board[CENTER][CENTER + 2] = Piece.ATTACKER;
            board[5][4] = Piece.ATTACKER;
            const after = simulateMove(board, { side: Side.ATTACKERS, from: [5, 4], to: [5, 5] });
            if (after[CENTER][CENTER + 1] !== Piece.KING) return false;
            const win = determineWin(after, { exitFortEnabled: false });
            return win == null;
          }
        },
        {
          name: 'Adjacent-to-throne: occupied throne does not count as capturing side',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            // (Illegal-ish) setup: throne occupied, king adjacent.
            board[CENTER][CENTER] = Piece.ATTACKER;
            board[CENTER][CENTER + 1] = Piece.KING;
            board[CENTER - 1][CENTER + 1] = Piece.ATTACKER;
            board[CENTER][CENTER + 2] = Piece.ATTACKER;
            // Missing S attacker: should NOT capture.
            return maybeCaptureKing(board, [CENTER, CENTER + 1]) === false;
          }
        },
        {
          name: 'Regression: Alex ply-13 king should NOT be captured (I7→G7)',
          run: () => {
            let board = initialBoard();

            const applyWithCaptures = (b, mv) => {
              const shifted = movePiece(b, mv.from, mv.to);
              const result = captureEnemyPieces(shifted, mv.to, mv.side);
              return result;
            };

            const moves = [
              { side: Side.ATTACKERS, from: 'D11', to: 'D10' },
              { side: Side.DEFENDERS, from: 'H6', to: 'H9' },
              { side: Side.ATTACKERS, from: 'H11', to: 'H10' },
              { side: Side.DEFENDERS, from: 'F8', to: 'H8' },
              { side: Side.ATTACKERS, from: 'E11', to: 'E10' },
              { side: Side.DEFENDERS, from: 'G7', to: 'G10' },
              { side: Side.ATTACKERS, from: 'F11', to: 'E11' },
              { side: Side.DEFENDERS, from: 'F7', to: 'I7' },
              { side: Side.ATTACKERS, from: 'F10', to: 'F8' },
              { side: Side.DEFENDERS, from: 'I7', to: 'I10' },
              { side: Side.ATTACKERS, from: 'K7', to: 'I7' },
              { side: Side.DEFENDERS, from: 'F6', to: 'F7' }
            ];

            for (const step of moves) {
              const mv = { side: step.side, from: parseNotation(step.from), to: parseNotation(step.to) };
              board = simulateMove(board, mv);
            }

            // Final ply 13 move, but keep capture metadata for assertion.
            const last = { side: Side.ATTACKERS, from: parseNotation('I7'), to: parseNotation('G7') };
            const afterLast = applyWithCaptures(board, last);
            board = afterLast.board;

            // Ensure the last move did NOT capture the king.
            if (afterLast.captured.some(x => x.piece === Piece.KING)) return false;

            const [kr, kc] = parseNotation('F7');
            if (board[kr][kc] !== Piece.KING) return false;

            // Validate the exact bug geometry at this point:
            // King at F7, N=attacker, E=attacker, W=defender, S=empty throne.
            const [nr, nc] = [kr - 1, kc];
            const [er, ec] = [kr, kc + 1];
            const [wr, wc] = [kr, kc - 1];
            const [sr, sc] = [kr + 1, kc];
            if (board[nr][nc] !== Piece.ATTACKER) return false;
            if (board[er][ec] !== Piece.ATTACKER) return false;
            if (board[wr][wc] !== Piece.DEFENDER) return false;
            if (coordKey(sr, sc) !== throneKey) return false;
            if (board[sr][sc] !== Piece.EMPTY) return false;

            // In particular, the king should not be considered capturable in this position.
            if (maybeCaptureKing(board, [kr, kc])) return false;

            // And the game should NOT end with a king-captured win here.
            const win = determineWin(board, { exitFortEnabled: false });
            return win == null;
          }
        },
        {
          name: 'UI flow: executeMove ply-13 sequence does not end game (I7→G7)',
          run: () => {
            let prevReq = null;
            try {
              // Prevent the UI loop from trying to request an AI move in headless mode.
              prevReq = requestAIMove;
              requestAIMove = () => {};

              sideSelect.value = Side.ATTACKERS;
              exitFortToggle.checked = false;
              restartGame();

              const steps = [
                { side: Side.ATTACKERS, from: 'D11', to: 'D10' },
                { side: Side.DEFENDERS, from: 'H6', to: 'H9' },
                { side: Side.ATTACKERS, from: 'H11', to: 'H10' },
                { side: Side.DEFENDERS, from: 'F8', to: 'H8' },
                { side: Side.ATTACKERS, from: 'E11', to: 'E10' },
                { side: Side.DEFENDERS, from: 'G7', to: 'G10' },
                { side: Side.ATTACKERS, from: 'F11', to: 'E11' },
                { side: Side.DEFENDERS, from: 'F7', to: 'I7' },
                { side: Side.ATTACKERS, from: 'F10', to: 'F8' },
                { side: Side.DEFENDERS, from: 'I7', to: 'I10' },
                { side: Side.ATTACKERS, from: 'K7', to: 'I7' },
                { side: Side.DEFENDERS, from: 'F6', to: 'F7' },
                { side: Side.ATTACKERS, from: 'I7', to: 'G7' }
              ];

              for (const s of steps) {
                executeMove({ side: s.side, from: parseNotation(s.from), to: parseNotation(s.to) });
                if (state.gameOver) break;
              }

              if (state.gameOver) return false;
              const [kr, kc] = parseNotation('F7');
              if (state.board[kr][kc] !== Piece.KING) return false;

              // Strong assertion: the last move should have recorded a king-capture check
              // with the exact reported geometry, and capture must be false.
              const last = state.moveHistory[state.moveHistory.length - 1];
              if (!last) return false;
              const checks = Array.isArray(last.kingCaptureChecks) ? last.kingCaptureChecks : [];
              const checkF7 = checks.find(x => x && x.king === 'F7');
              if (!checkF7) return false;
              if (checkF7.adjacentToThrone !== true) return false;
              if (checkF7.capture !== false) return false;
              // Reported neighbors at time of evaluation: N=A, E=A, W=D, S=empty throne.
              if (!String(checkF7.N).startsWith('A')) return false;
              if (!String(checkF7.E).startsWith('A')) return false;
              if (!String(checkF7.W).startsWith('D')) return false;
              if (!String(checkF7.S).startsWith('empty') || !String(checkF7.S).includes('(throne)')) return false;

              return true;
            } catch (e) {
              return false;
            } finally {
              if (prevReq) requestAIMove = prevReq;
            }
          }
        },
        {
          name: 'Repetition: defenders lose on 3x repetition',
          run: () => {
            const history = ['posA', 'posB', 'posA', 'posC', 'posA'];
            return repetitionLoser(history, Side.DEFENDERS) === Side.DEFENDERS;
          }
        },
        {
          name: 'Repetition: attackers do not auto-lose',
          run: () => {
            const history = ['posA', 'posB', 'posA', 'posC', 'posA'];
            return repetitionLoser(history, Side.ATTACKERS) == null;
          }
        },
        {
          name: 'King capture ends in attackers win',
          run: () => {
            let board = initialBoard();
            board[CENTER][CENTER - 1] = Piece.ATTACKER;
            board[CENTER][CENTER + 1] = Piece.ATTACKER;
            board[CENTER - 1][CENTER] = Piece.ATTACKER;
            board[CENTER + 1][CENTER] = Piece.ATTACKER;
            const result = determineWin(board, { exitFortEnabled: false });
            return result?.winner === Side.ATTACKERS;
          }
        },
        {
          name: 'King on throne requires 4 attackers (3 attackers is not enough)',
          run: () => {
            const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
            board[CENTER][CENTER] = Piece.KING;
            board[CENTER - 1][CENTER] = Piece.ATTACKER;
            board[CENTER + 1][CENTER] = Piece.ATTACKER;
            board[CENTER][CENTER - 1] = Piece.ATTACKER;
            // With only 3 attackers, the king must not be capturable.
            if (maybeCaptureKing(board, [CENTER, CENTER])) return false;
            const win = determineWin(board, { exitFortEnabled: false });
            return win == null;
          }
        }
      ];
    }

    function runRegressionTests() {
      const scenarios = regressionScenarios();
      const failures = [];
      scenarios.forEach(test => {
        const ok = test.run();
        if (!ok) failures.push(test.name);
      });

      // Also validate the worker copy of critical rules (prevents UI/worker divergence).
      testStatusEl.textContent = failures.length
        ? `Regression failures: ${failures.join(', ')}`
        : `Regression tests passed (${scenarios.length}); verifying worker…`;
      testStatusEl.classList.toggle('bad', failures.length > 0);
      testStatusEl.classList.toggle('good', failures.length === 0);

      engineManager.selfTest().then((result) => {
        if (!result?.ok) {
          const list = (result?.failures || []).join(', ') || 'unknown';
          testStatusEl.textContent = `Worker self-test failures: ${list}`;
          testStatusEl.classList.remove('good');
          testStatusEl.classList.add('bad');
          return;
        }
        if (failures.length) return;
        testStatusEl.textContent = `Regression tests passed (${scenarios.length})`;
        testStatusEl.classList.remove('bad');
        testStatusEl.classList.add('good');
      }).catch((err) => {
        testStatusEl.textContent = `Worker self-test error: ${err?.message || String(err)}`;
        testStatusEl.classList.remove('good');
        testStatusEl.classList.add('bad');
      });
    }

    function runSmokeChecklist() {
      let board = initialBoard();
      let side = Side.ATTACKERS;
      let rng = createRng(123456789);
      for (let ply = 0; ply < 20; ply++) {
        const moves = allMoves(board, side);
        if (!moves.length) break;
        const choice = moves[Math.floor(rng() * moves.length)];
        board = simulateMove(board, choice);
        const win = determineWin(board, { exitFortEnabled: false });
        if (win) {
          telemetryNote.textContent = `Checklist detected premature win on ply ${ply + 1}: ${win.reason}`;
          return;
        }
        side = opposite(side);
      }
      telemetryNote.textContent = 'Checklist: 20-ply smoke test completed without premature wins.';
    }

    class EngineWorkerManager {
      constructor() {
        this.workerUrl = null;
        this.worker = null;
        this.moveRequestId = 0;
        this.pending = new Map();
        this.activeToken = 0;
        this.ensureWorker();
      }

      ensureWorker() {
        if (this.worker) return;
        if (!this.workerUrl) {
          const source = document.getElementById('engine-worker').textContent;
          this.workerUrl = URL.createObjectURL(new Blob([source], { type: 'application/javascript' }));
        }
        this.worker = new Worker(this.workerUrl, { name: 'hnefatafl-engine' });
        this.worker.onmessage = (event) => {
          const { type, id, payload, error } = event.data;
          const pending = this.pending.get(id);
          if (!pending) return;
          if (type === 'MOVE_RESULT' || type === 'SELF_PLAY_RESULT' || type === 'SELF_TEST_RESULT') {
            this.pending.delete(id);
            if (error) {
              pending.reject(new Error(error));
            } else {
              pending.resolve(payload);
            }
          }
        };
        this.worker.onerror = (err) => {
          console.warn('Engine worker error', err);
          this.resetWorker();
        };
      }

      resetWorker() {
        if (this.worker) {
          this.worker.terminate();
          this.worker = null;
        }
        this.ensureWorker();
      }

      cancelCurrent() {
        this.activeToken += 1;
      }

      requestMove(payload) {
        this.ensureWorker();
        const id = `move-${++this.moveRequestId}`;
        const enriched = { ...payload, id, type: 'MOVE_REQUEST' };
        const token = this.activeToken;
        const promise = new Promise((resolve, reject) => {
          this.pending.set(id, {
            resolve: (data) => {
              if (token !== this.activeToken) {
                resolve(null);
                return;
              }
              resolve(data);
            },
            reject
          });
        });
        this.worker.postMessage(enriched);
        return promise;
      }

      selfTest() {
        this.ensureWorker();
        const id = `test-${++this.moveRequestId}`;
        const promise = new Promise((resolve, reject) => {
          this.pending.set(id, { resolve, reject });
        });
        this.worker.postMessage({ type: 'SELF_TEST', id });
        return promise;
      }

      runSelfPlay(options) {
        const source = document.getElementById('engine-worker').textContent;
        const url = URL.createObjectURL(new Blob([source], { type: 'application/javascript' }));
        const worker = new Worker(url, { name: 'hnefatafl-selfplay' });
        const id = `self-${Date.now()}`;
        return new Promise((resolve, reject) => {
          worker.onmessage = (event) => {
            if (event.data.id !== id) return;
            const { payload, error } = event.data;
            worker.terminate();
            URL.revokeObjectURL(url);
            if (error) reject(new Error(error));
            else resolve(payload);
          };
          worker.onerror = (err) => {
            worker.terminate();
            URL.revokeObjectURL(url);
            reject(err);
          };
          worker.postMessage({
            type: 'SELF_PLAY',
            id,
            games: options.games,
            maxDepth: options.maxDepth,
            moveTimeMs: options.moveTimeMs,
            exitFortEnabled: options.exitFortEnabled,
            maxPly: options.maxPly,
            initialBoard: options.initialBoard.map(row => row.slice())
          });
        });
      }
    }

    const engineManager = new EngineWorkerManager();

    function getDifficultySettings() {
      const profile = DifficultyProfiles[difficultySelect.value] || DifficultyProfiles.standard;
      return { moveTimeMs: profile.moveTimeMs, maxDepth: profile.maxDepth };
    }

    function resetEngineStats() {
      statDepth.textContent = '–';
      statNodes.textContent = '–';
      statEval.textContent = '–';
      statTime.textContent = '–';
      statPV.textContent = 'PV: —';
    }

    function updateEngineStats(stats) {
      if (!stats) {
        resetEngineStats();
        return;
      }
      statDepth.textContent = stats.depth ?? '–';
      const nodes = stats.nodes != null ? `${(stats.nodes / 1000).toFixed(1)}k` : '–';
      statNodes.textContent = nodes;
      statEval.textContent = stats.eval != null ? `${stats.eval >= 0 ? '+' : ''}${(stats.eval / 100).toFixed(2)}` : '–';
      statTime.textContent = stats.timeMs != null ? `${stats.timeMs.toFixed(0)} ms` : '–';
      const pvText = stats.pv?.length
        ? `PV: ${stats.pv.map(move => `${notation(move.from)}→${notation(move.to)}`).join(' · ')}`
        : 'PV: —';
      statPV.textContent = pvText;
    }

    function fallbackRandomMove() {
      const moves = allMoves(state.board, state.currentSide);
      if (!moves.length) {
        const winner = opposite(state.currentSide);
        endGame(winner, `${state.currentSide} cannot move`);
        return;
      }
      const choice = randomChoice(moves);
      executeMove(choice);
    }

    function requestAIMove() {
      if (state.gameOver) return;
      const settings = getDifficultySettings();
      engineStatusEl.textContent = `Thinking (${DifficultyProfiles[difficultySelect.value]?.label ?? 'Standard'})…`;
      const engineToken = ++state.engineToken;
      engineManager
        .requestMove({
          board: state.board.map(row => row.slice()),
          side: state.currentSide,
          settings,
          config: { exitFortEnabled: state.config.exitFortEnabled }
        })
        .then(result => {
          if (!result) {
            engineStatusEl.textContent = 'Idle';
            return;
          }
          if (state.gameOver || engineToken !== state.engineToken) {
            engineStatusEl.textContent = 'Idle';
            return;
          }
          engineStatusEl.textContent = 'Move ready';
          updateEngineStats(result.stats);
          if (!result.move) {
            fallbackRandomMove();
            engineStatusEl.textContent = 'Idle';
            return;
          }
          executeMove(result.move);
          engineStatusEl.textContent = 'Idle';
        })
        .catch(err => {
          console.error('Engine move failed', err);
          engineStatusEl.textContent = 'Engine fallback';
          fallbackRandomMove();
          engineStatusEl.textContent = 'Idle';
        });
    }

    function runSelfPlayHarness() {
      if (state.currentSide !== state.playerSide) {
        telemetryNote.textContent = 'Self-play disabled while engine turn is pending.';
        return;
      }
      selfPlayBtn.disabled = true;
      telemetryNote.textContent = 'Self-play batch running…';
      engineManager
        .runSelfPlay({
          games: 3,
          maxDepth: 4,
          moveTimeMs: 120,
          exitFortEnabled: state.config.exitFortEnabled,
          maxPly: 80,
          initialBoard: state.board.map(row => row.slice())
        })
        .then(results => {
          const defendersWins = results.filter(r => r.winner === Side.DEFENDERS).length;
          const attackersWins = results.filter(r => r.winner === Side.ATTACKERS).length;
          const unfinished = results.length - defendersWins - attackersWins;
          telemetryNote.textContent = `Self-play: ${defendersWins} defender wins, ${attackersWins} attacker wins, ${unfinished} unfinished.`;
        })
        .catch(err => {
          telemetryNote.textContent = `Self-play failed: ${err.message}`;
        })
        .finally(() => {
          selfPlayBtn.disabled = false;
        });
    }

    restartBtn.addEventListener('click', restartGame);
    sideSelect.addEventListener('change', restartGame);
    difficultySelect.addEventListener('change', () => {
      if (!state.gameOver && state.currentSide !== state.playerSide) {
        engineManager.cancelCurrent();
        requestAIMove();
      }
    });
    exitFortToggle.addEventListener('change', () => {
      state.config.exitFortEnabled = !!exitFortToggle.checked;
    });
    refreshLogsBtn.addEventListener('click', refreshLogViewer);
    downloadJsonBtn.addEventListener('click', () => {
      if (!storedGames.length) return;
      downloadFile(JSON.stringify(storedGames, null, 2), 'hnefatafl-logs.json');
    });
    downloadCsvBtn.addEventListener('click', () => {
      if (!storedGames.length) return;
      downloadFile(toCsv(storedGames), 'hnefatafl-logs.csv', 'text/csv');
    });
    clearLogsBtn.addEventListener('click', clearLogs);
    copyBugBtn.addEventListener('click', copyBugReport);
    selfPlayBtn.addEventListener('click', runSelfPlayHarness);

    setupBoardGrid();
    runRegressionTests();
    runSmokeChecklist();
    refreshLogViewer();
    restartGame();
  </script>
</body>
</html>
