<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hnefatafl Engine (Copenhagen Rules)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #070a11;
      --panel: #0f1624;
      --panel-border: rgba(255, 255, 255, 0.04);
      --accent: #8ad0ff;
      --accent-strong: #58a6ff;
      --text: #f4f7ff;
      --muted: #96a3ba;
      --board-light: #f0d9b5;
      --board-dark: #b58863;
      --attacker: #1c1d21;
      --defender: #fdfcfa;
      --king: #f4c95d;
      --legal-dot: rgba(137, 208, 255, 0.92);
      --last-move-from: rgba(88, 134, 255, 0.45);
      --last-move-to: rgba(234, 197, 119, 0.6);
      --capture-flash: rgba(255, 116, 116, 0.5);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #131b2e, var(--bg));
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem 4rem;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.75rem, 4vw, 2.5rem);
      letter-spacing: 0.04em;
    }

    .app-shell {
      width: min(1200px, 100%);
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }

    .board-panel {
      grid-column: span 2;
      background: var(--panel);
      border-radius: 1.35rem;
      padding: 1.75rem;
      border: 1px solid var(--panel-border);
      box-shadow: 0 25px 70px rgba(0, 0, 0, 0.45);
    }

    .toolbar {
      display: flex;
      gap: 1.25rem;
      flex-wrap: wrap;
    }

    .board-wrapper {
      position: relative;
      margin-top: 1.25rem;
      width: min(92vw, 640px);
      max-width: 100%;
      margin-left: auto;
      margin-right: auto;
    }

    .board-grid {
      display: grid;
      grid-template-columns: repeat(11, 1fr);
      grid-auto-rows: 1fr;
      gap: 4px;
      width: 100%;
      aspect-ratio: 1;
      padding: 0.85rem;
      border-radius: 1.25rem;
      background: radial-gradient(circle at top, #c9ad88, #9b6d44);
      box-shadow: inset 0 1px 20px rgba(0, 0, 0, 0.45);
    }

    .cell {
      position: relative;
      border: none;
      border-radius: 0.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1;
      padding: 0;
      transition: transform 140ms ease, box-shadow 140ms ease;
      background-size: cover;
    }

    .cell-light {
      background: var(--board-light);
    }

    .cell-light::after,
    .cell-dark::after,
    .cell::before {
      pointer-events: none;
    }

    .cell-dark {
      background: var(--board-dark);
    }

    .cell:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .cell:hover {
      transform: translateY(-2px);
    }

    .cell.selected {
      box-shadow: inset 0 0 0 3px rgba(138, 208, 255, 0.85);
    }

    .cell::before {
      content: "";
      position: absolute;
      inset: 6%;
      border-radius: 0.45rem;
      opacity: 0;
      transition: opacity 160ms ease;
    }

    .cell.last-move-from::before {
      background: var(--last-move-from);
      opacity: 1;
    }

    .cell.last-move-to::before {
      background: var(--last-move-to);
      opacity: 1;
    }

    .cell.capture-flash::before {
      background: var(--capture-flash);
      opacity: 1;
    }

    .cell.legal-move::after {
      content: "";
      width: 28%;
      height: 28%;
      background: var(--legal-dot);
      border-radius: 50%;
      box-shadow: 0 0 12px rgba(138, 208, 255, 0.8);
      opacity: 0.85;
    }

    .piece {
      width: 70%;
      aspect-ratio: 1;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: clamp(0.85rem, 1.8vw, 1.2rem);
      letter-spacing: 0.02em;
      pointer-events: none;
      transition: filter 160ms ease;
    }

    .piece.attacker {
      background: radial-gradient(circle at 30% 30%, #3c3c43, var(--attacker));
      color: #f2f4ff;
      border: 2px solid rgba(255, 255, 255, 0.18);
      box-shadow: inset 0 6px 12px rgba(255, 255, 255, 0.08);
    }

    .piece.defender {
      background: radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9);
      color: #1d1c19;
      border: 2px solid rgba(0, 0, 0, 0.15);
      box-shadow: inset 0 6px 12px rgba(0, 0, 0, 0.08);
    }

    .piece.king {
      background: radial-gradient(circle at 30% 30%, #ffeeb7, var(--king));
      border: 2px solid #c38b29;
      color: #2b1d07;
      font-size: clamp(1rem, 2.5vw, 1.45rem);
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.75);
      box-shadow: inset 0 8px 16px rgba(255, 255, 255, 0.25);
    }

    .capture-toast {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translate(-50%, 150%);
      padding: 0.55rem 1.2rem;
      border-radius: 999px;
      background: rgba(8, 11, 18, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text);
      opacity: 0;
      transition: opacity 200ms ease, transform 200ms ease;
      pointer-events: none;
    }

    .capture-toast.visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .controls,
    .status,
    .transcript {
      background: var(--panel);
      border-radius: 1.25rem;
      padding: 1.25rem;
      border: 1px solid var(--panel-border);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.3);
    }

    .controls label,
    .status p {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.75rem;
    }

    .controls select,
    .controls button {
      width: 100%;
      padding: 0.85rem 1rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }

    .controls button:hover,
    .controls select:focus-visible {
      background: rgba(138, 208, 255, 0.18);
      transform: translateY(-1px);
    }

    .status {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .status .badge {
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: capitalize;
      width: fit-content;
    }

    .badge.attackers {
      background: rgba(28, 29, 33, 0.4);
      color: #f2f4ff;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .badge.defenders {
      background: rgba(253, 252, 250, 0.1);
      color: var(--defender);
      border: 1px solid rgba(253, 252, 250, 0.2);
    }

    .status .message {
      font-size: 1rem;
      color: var(--text);
      line-height: 1.5;
    }

    .transcript {
      max-height: 420px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .move-row {
      display: flex;
      align-items: baseline;
      gap: 0.65rem;
      font-variant-numeric: tabular-nums;
      padding-bottom: 0.45rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .move-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .move-index {
      color: var(--muted);
      width: 2.5rem;
    }

    .move-text {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .move-side {
      text-transform: capitalize;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .move-description {
      font-weight: 600;
    }

    @media (max-width: 900px) {
      .board-panel {
        grid-column: span 1;
      }

      .board-wrapper {
        width: 100%;
      }

      .board-grid {
        gap: 3px;
        padding: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <h1>Hnefatafl Engine · Copenhagen Rules</h1>
  <div class="app-shell">
    <section class="board-panel">
      <div class="toolbar">
        <div class="controls" style="flex:1; min-width:220px;">
          <label for="sideSelect">Play as</label>
          <select id="sideSelect">
            <option value="defenders">Defenders (White)</option>
            <option value="attackers">Attackers (Black)</option>
          </select>
          <button id="restartBtn" style="margin-top:0.75rem;">Restart Game</button>
        </div>
        <div class="status" style="flex:1; min-width:220px;">
          <p>Current Turn</p>
          <span id="turnBadge" class="badge attackers">Attackers</span>
          <p>Game State</p>
          <div id="statusMessage" class="message">Attackers to move.</div>
        </div>
      </div>
      <div class="board-wrapper">
        <div id="board" class="board-grid" aria-label="Copenhagen Hnefatafl board"></div>
        <div id="captureToast" class="capture-toast" aria-live="assertive"></div>
      </div>
    </section>
    <section class="transcript" aria-live="polite" aria-label="Move transcript">
      <h2 style="margin-top:0; font-size:1.1rem;">Move List</h2>
      <div id="moves"></div>
    </section>
  </div>

  <script>
    const SIZE = 11;
    const CENTER = Math.floor(SIZE / 2);
    const Piece = Object.freeze({
      EMPTY: '.',
      ATTACKER: 'A',
      DEFENDER: 'D',
      KING: 'K'
    });

    const Side = Object.freeze({
      ATTACKERS: 'attackers',
      DEFENDERS: 'defenders'
    });

    const restrictedSquares = new Set([
      `${CENTER},${CENTER}`,
      `0,0`, `0,${SIZE - 1}`, `${SIZE - 1},0`, `${SIZE - 1},${SIZE - 1}`
    ]);

    const throneKey = `${CENTER},${CENTER}`;

    const directions = [
      [1, 0],
      [-1, 0],
      [0, 1],
      [0, -1]
    ];

    const boardEl = document.getElementById('board');
    const movesEl = document.getElementById('moves');
    const restartBtn = document.getElementById('restartBtn');
    const sideSelect = document.getElementById('sideSelect');
    const statusMessage = document.getElementById('statusMessage');
    const turnBadge = document.getElementById('turnBadge');
    const captureToast = document.getElementById('captureToast');

    const cellRefs = new Map();
    const piecePool = new Map();
    let captureToastTimeoutId = null;
    let captureFlashTimeoutId = null;
    let state = {};

    function cloneBoard(board) {
      return board.map(row => [...row]);
    }

    function initialBoard() {
      const layout = Array.from({ length: SIZE }, () => Array(SIZE).fill(Piece.EMPTY));
      const attackers = [
        [0, 3], [0, 4], [0, 5], [0, 6], [0, 7],
        [1, 5],
        [3, 0], [4, 0], [5, 0], [6, 0], [7, 0],
        [5, 1],
        [10, 3], [10, 4], [10, 5], [10, 6], [10, 7],
        [9, 5],
        [3, 10], [4, 10], [5, 10], [6, 10], [7, 10],
        [5, 9]
      ];

      const defenders = [
        [CENTER - 2, CENTER], [CENTER - 1, CENTER],
        [CENTER + 1, CENTER], [CENTER + 2, CENTER],
        [CENTER, CENTER - 2], [CENTER, CENTER - 1],
        [CENTER, CENTER + 1], [CENTER, CENTER + 2],
        [CENTER - 1, CENTER - 1], [CENTER - 1, CENTER + 1],
        [CENTER + 1, CENTER - 1], [CENTER + 1, CENTER + 1]
      ];

      attackers.forEach(([r, c]) => (layout[r][c] = Piece.ATTACKER));
      defenders.forEach(([r, c]) => (layout[r][c] = Piece.DEFENDER));
      layout[CENTER][CENTER] = Piece.KING;
      return layout;
    }

    function createIdBoard(board) {
      let counter = 0;
      return board.map(row => row.map(cell => (cell === Piece.EMPTY ? null : `piece-${counter++}`)));
    }

    function coordKey(r, c) {
      return `${r},${c}`;
    }

    function isInside(r, c) {
      return r >= 0 && c >= 0 && r < SIZE && c < SIZE;
    }

    function isRestricted(r, c) {
      return restrictedSquares.has(coordKey(r, c));
    }

    function isCorner(r, c) {
      return (r === 0 || r === SIZE - 1) && (c === 0 || c === SIZE - 1);
    }

    function pieceBelongsTo(piece, side) {
      if (piece === Piece.EMPTY) return false;
      if (side === Side.ATTACKERS) return piece === Piece.ATTACKER;
      return piece === Piece.DEFENDER || piece === Piece.KING;
    }

    function opposite(side) {
      return side === Side.ATTACKERS ? Side.DEFENDERS : Side.ATTACKERS;
    }

    function isHostileSquareAgainst(side, r, c, board) {
      const key = coordKey(r, c);
      if (key === throneKey) {
        if (side === Side.ATTACKERS) return true;
        return board[r][c] === Piece.EMPTY;
      }
      if (isCorner(r, c)) {
        return board[r][c] === Piece.EMPTY || !pieceBelongsTo(board[r][c], side);
      }
      return false;
    }

    function getLegalMoves(board, r, c, side) {
      const piece = board[r][c];
      if (!pieceBelongsTo(piece, side)) return [];
      const moves = [];
      for (const [dr, dc] of directions) {
        let nr = r + dr;
        let nc = c + dc;
        while (isInside(nr, nc) && board[nr][nc] === Piece.EMPTY) {
          if (isRestricted(nr, nc) && piece !== Piece.KING) {
            if (coordKey(nr, nc) === throneKey) {
              nr += dr;
              nc += dc;
              continue;
            }
            break;
          }
          moves.push([nr, nc]);
          nr += dr;
          nc += dc;
        }
      }
      return moves;
    }

    function movePiece(board, from, to) {
      const newBoard = cloneBoard(board);
      const [fr, fc] = from;
      const [tr, tc] = to;
      newBoard[tr][tc] = newBoard[fr][fc];
      newBoard[fr][fc] = Piece.EMPTY;
      return newBoard;
    }

    function captureEnemyPieces(board, movedTo, moverSide) {
      const newBoard = cloneBoard(board);
      const opponent = opposite(moverSide);
      const captured = [];

      for (const [dr, dc] of directions) {
        const adjR = movedTo[0] + dr;
        const adjC = movedTo[1] + dc;
        if (!isInside(adjR, adjC)) continue;
        const adjPiece = newBoard[adjR][adjC];
        if (!pieceBelongsTo(adjPiece, opponent)) continue;

        if (adjPiece === Piece.KING) {
          if (maybeCaptureKing(newBoard, [adjR, adjC])) {
            newBoard[adjR][adjC] = Piece.EMPTY;
            captured.push({ r: adjR, c: adjC, piece: Piece.KING });
          }
          continue;
        }

        const beyondR = adjR + dr;
        const beyondC = adjC + dc;
        const beyondHostile =
          (isInside(beyondR, beyondC) && pieceBelongsTo(newBoard[beyondR][beyondC], moverSide)) ||
          (isInside(beyondR, beyondC) && isHostileSquareAgainst(opponent, beyondR, beyondC, newBoard));

        if (beyondHostile) {
          newBoard[adjR][adjC] = Piece.EMPTY;
          captured.push({ r: adjR, c: adjC, piece: adjPiece });
        }
      }

      const shieldCaptures = applyShieldwall(newBoard, moverSide);
      return { board: newBoard, captured: [...captured, ...shieldCaptures] };
    }

    function maybeCaptureKing(board, pos) {
      const [r, c] = pos;
      if (r === 0 || r === SIZE - 1 || c === 0 || c === SIZE - 1) {
        return false;
      }
      let hostileCount = 0;
      for (const [dr, dc] of directions) {
        const nr = r + dr;
        const nc = c + dc;
        if (!isInside(nr, nc)) continue;
        const occupant = board[nr][nc];
        if (occupant === Piece.ATTACKER) {
          hostileCount += 1;
          continue;
        }
        if (isHostileSquareAgainst(Side.DEFENDERS, nr, nc, board)) {
          hostileCount += 1;
        }
      }

      const adjacentToThrone = Math.abs(r - CENTER) + Math.abs(c - CENTER) === 1;
      const required = adjacentToThrone ? 3 : 4;
      if (coordKey(r, c) === throneKey) {
        return hostileCount >= 4;
      }
      return hostileCount >= required;
    }

    function applyShieldwall(board, moverSide) {
      const opponent = opposite(moverSide);
      const captured = [];

      const bracketSatisfied = (row, col) => {
        if (!isInside(row, col)) return false;
        if (isCorner(row, col)) return true;
        return pieceBelongsTo(board[row][col], moverSide);
      };

      const scanHorizontal = (edgeRow) => {
        const innerRow = edgeRow === 0 ? 1 : SIZE - 2;
        let col = 0;
        while (col < SIZE) {
          if (!pieceBelongsTo(board[edgeRow][col], opponent)) {
            col += 1;
            continue;
          }
          const start = col;
          while (col < SIZE && pieceBelongsTo(board[edgeRow][col], opponent)) {
            col += 1;
          }
          const end = col - 1;
          if (end - start + 1 < 2) continue;
          const leftIdx = start - 1;
          const rightIdx = end + 1;
          const touchesLeftCorner = start === 0 && isCorner(edgeRow, 0);
          const touchesRightCorner = end === SIZE - 1 && isCorner(edgeRow, SIZE - 1);
          const leftOk = touchesLeftCorner || (leftIdx >= 0 && bracketSatisfied(edgeRow, leftIdx));
          const rightOk = touchesRightCorner || (rightIdx < SIZE && bracketSatisfied(edgeRow, rightIdx));
          if (!leftOk || !rightOk) continue;
          let support = true;
          for (let c = start; c <= end; c++) {
            if (!pieceBelongsTo(board[innerRow][c], moverSide)) {
              support = false;
              break;
            }
          }
          if (!support) continue;
          for (let c = start; c <= end; c++) {
            if (board[edgeRow][c] === Piece.KING) continue;
            captured.push({ r: edgeRow, c, piece: board[edgeRow][c] });
            board[edgeRow][c] = Piece.EMPTY;
          }
        }
      };

      const scanVertical = (edgeCol) => {
        const innerCol = edgeCol === 0 ? 1 : SIZE - 2;
        let row = 0;
        while (row < SIZE) {
          if (!pieceBelongsTo(board[row][edgeCol], opponent)) {
            row += 1;
            continue;
          }
          const start = row;
          while (row < SIZE && pieceBelongsTo(board[row][edgeCol], opponent)) {
            row += 1;
          }
          const end = row - 1;
          if (end - start + 1 < 2) continue;
          const topIdx = start - 1;
          const bottomIdx = end + 1;
          const touchesTopCorner = start === 0 && isCorner(0, edgeCol);
          const touchesBottomCorner = end === SIZE - 1 && isCorner(SIZE - 1, edgeCol);
          const topOk = touchesTopCorner || (topIdx >= 0 && bracketSatisfied(topIdx, edgeCol));
          const bottomOk = touchesBottomCorner || (bottomIdx < SIZE && bracketSatisfied(bottomIdx, edgeCol));
          if (!topOk || !bottomOk) continue;
          let support = true;
          for (let r = start; r <= end; r++) {
            if (!pieceBelongsTo(board[r][innerCol], moverSide)) {
              support = false;
              break;
            }
          }
          if (!support) continue;
          for (let r = start; r <= end; r++) {
            if (board[r][edgeCol] === Piece.KING) continue;
            captured.push({ r, c: edgeCol, piece: board[r][edgeCol] });
            board[r][edgeCol] = Piece.EMPTY;
          }
        }
      };

      scanHorizontal(0);
      scanHorizontal(SIZE - 1);
      scanVertical(0);
      scanVertical(SIZE - 1);

      return captured;
    }

    function hasLegalMove(board, side) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (pieceBelongsTo(board[r][c], side) && getLegalMoves(board, r, c, side).length) {
            return true;
          }
        }
      }
      return false;
    }

    function locateKing(board) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] === Piece.KING) return [r, c];
        }
      }
      return null;
    }

    function defendersEncircled(board) {
      const kingPos = locateKing(board);
      if (!kingPos) return true;
      const visited = new Set();
      const queue = [kingPos];
      visited.add(coordKey(...kingPos));

      while (queue.length) {
        const [r, c] = queue.shift();
        if (r === 0 || c === 0 || r === SIZE - 1 || c === SIZE - 1) {
          return false;
        }
        for (const [dr, dc] of directions) {
          const nr = r + dr;
          const nc = c + dc;
          if (!isInside(nr, nc)) continue;
          const key = coordKey(nr, nc);
          if (visited.has(key)) continue;
          const cell = board[nr][nc];
          if (cell === Piece.EMPTY || pieceBelongsTo(cell, Side.DEFENDERS)) {
            visited.add(key);
            queue.push([nr, nc]);
          }
        }
      }
      return true;
    }

    function simulateMove(board, move) {
      const { from, to, side } = move;
      const shifted = movePiece(board, from, to);
      const result = captureEnemyPieces(shifted, to, side);
      return result.board;
    }

    function attackersCanCaptureKing(board) {
      const attackersMoves = allMoves(board, Side.ATTACKERS);
      for (const mv of attackersMoves) {
        const next = simulateMove(board, mv);
        if (!locateKing(next)) {
          return true;
        }
      }
      return false;
    }

    function defendersExitFort(board) {
      const kingPos = locateKing(board);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      const onEdge = kr === 0 || kc === 0 || kr === SIZE - 1 || kc === SIZE - 1;
      if (!onEdge) return false;
      const kingMoves = getLegalMoves(board, kr, kc, Side.DEFENDERS);
      if (!kingMoves.length) return false;
      return !attackersCanCaptureKing(board);
    }

    function allMoves(board, side) {
      const moves = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (!pieceBelongsTo(board[r][c], side)) continue;
          const legal = getLegalMoves(board, r, c, side);
          for (const [nr, nc] of legal) {
            moves.push({ side, from: [r, c], to: [nr, nc] });
          }
        }
      }
      return moves;
    }

    function determineWin(board) {
      const kingPos = locateKing(board);
      if (!kingPos) {
        return { winner: Side.ATTACKERS, reason: 'King captured • attackers win' };
      }
      if (isCorner(...kingPos)) {
        return { winner: Side.DEFENDERS, reason: 'King reached a corner • defenders win' };
      }
      if (defendersExitFort(board)) {
        return { winner: Side.DEFENDERS, reason: 'Exit fort established • defenders win' };
      }
      if (defendersEncircled(board)) {
        return { winner: Side.ATTACKERS, reason: 'Defenders encircled • attackers win' };
      }
      if (!hasLegalMove(board, Side.ATTACKERS)) {
        return { winner: Side.DEFENDERS, reason: 'Attackers have no legal moves' };
      }
      if (!hasLegalMove(board, Side.DEFENDERS)) {
        return { winner: Side.ATTACKERS, reason: 'Defenders have no legal moves' };
      }
      return null;
    }

    function repetitionKey(board) {
      return board.map(row => row.join('')).join('|');
    }

    function updateStatus(text, side) {
      statusMessage.textContent = text;
      turnBadge.textContent = side.charAt(0).toUpperCase() + side.slice(1);
      turnBadge.className = `badge ${side}`;
    }

    function setupBoardGrid() {
      boardEl.innerHTML = '';
      cellRefs.clear();
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const cellBtn = document.createElement('button');
          cellBtn.type = 'button';
          cellBtn.className = `cell ${(r + c) % 2 === 0 ? 'cell-light' : 'cell-dark'}`;
          cellBtn.dataset.row = r;
          cellBtn.dataset.col = c;
          cellBtn.setAttribute('aria-label', `Square ${notation([r, c])}`);
          cellBtn.addEventListener('click', () => onCellClick(r, c));
          boardEl.appendChild(cellBtn);
          cellRefs.set(coordKey(r, c), cellBtn);
        }
      }
    }

    function capturePiecePositions() {
      const positions = new Map();
      piecePool.forEach((el, id) => {
        positions.set(id, el.getBoundingClientRect());
      });
      return positions;
    }

    function renderBoard(prevPositions = null) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const key = coordKey(r, c);
          const cellBtn = cellRefs.get(key);
          if (!cellBtn) continue;
          const isLegal = state.legalTargets.has(key) && state.board[r][c] === Piece.EMPTY;
          cellBtn.classList.toggle('legal-move', isLegal);
          cellBtn.classList.toggle('selected', state.highlight && key === coordKey(...state.highlight));
          cellBtn.classList.toggle('last-move-from', state.lastMove && key === coordKey(...state.lastMove.from));
          cellBtn.classList.toggle('last-move-to', state.lastMove && key === coordKey(...state.lastMove.to));
          cellBtn.classList.toggle('capture-flash', state.captureFlash.has(key));

          const piece = state.board[r][c];
          const pieceId = state.idBoard?.[r]?.[c] ?? null;
          let pieceEl = pieceId ? piecePool.get(pieceId) : null;

          if (piece === Piece.EMPTY || !pieceId) {
            if (pieceEl) {
              pieceEl.remove();
              piecePool.delete(pieceId);
            }
            continue;
          }

          if (!pieceEl) {
            pieceEl = document.createElement('div');
            pieceEl.className = 'piece';
            pieceEl.dataset.pieceId = pieceId;
            piecePool.set(pieceId, pieceEl);
          }

          pieceEl.className = 'piece';
          if (piece === Piece.ATTACKER) {
            pieceEl.classList.add('attacker');
            pieceEl.textContent = '';
          } else if (piece === Piece.DEFENDER) {
            pieceEl.classList.add('defender');
            pieceEl.textContent = '';
          } else {
            pieceEl.classList.add('king');
            pieceEl.textContent = '♔';
          }

          if (pieceEl.parentElement !== cellBtn) {
            cellBtn.appendChild(pieceEl);
          } else {
            cellBtn.appendChild(pieceEl);
          }

          if (prevPositions && prevPositions.has(pieceId)) {
            const prev = prevPositions.get(pieceId);
            const next = pieceEl.getBoundingClientRect();
            const dx = prev.left - next.left;
            const dy = prev.top - next.top;
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
              pieceEl.animate([
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0, 0)' }
              ], {
                duration: 320,
                easing: 'cubic-bezier(0.22, 1, 0.36, 1)'
              });
            }
          }
        }
      }
    }

    function renderMoves() {
      movesEl.innerHTML = '';
      state.moveHistory.forEach((entry, idx) => {
        const row = document.createElement('div');
        row.className = 'move-row';
        const idxEl = document.createElement('span');
        idxEl.className = 'move-index';
        idxEl.textContent = idx + 1;
        const textEl = document.createElement('div');
        textEl.className = 'move-text';
        const sideEl = document.createElement('span');
        sideEl.className = 'move-side';
        sideEl.textContent = entry.side;
        const descEl = document.createElement('span');
        descEl.className = 'move-description';
        descEl.textContent = `${notation(entry.from)} → ${notation(entry.to)}${entry.captureSummary ? ' (' + entry.captureSummary + ')' : ''}`;
        textEl.append(sideEl, descEl);
        row.append(idxEl, textEl);
        movesEl.appendChild(row);
      });
      movesEl.scrollTop = movesEl.scrollHeight;
    }

    function notation([r, c]) {
      return String.fromCharCode(65 + c) + (SIZE - r);
    }

    function setHighlight(from, legal) {
      state.highlight = from;
      state.legalTargets = new Set(legal.map(([r, c]) => coordKey(r, c)));
    }

    function clearHighlight() {
      state.highlight = null;
      state.legalTargets = new Set();
    }

    function isPlayerTurn() {
      return state.currentSide === state.playerSide && !state.gameOver;
    }

    function onCellClick(r, c) {
      if (!isPlayerTurn()) return;
      const key = coordKey(r, c);
      if (state.highlight && state.legalTargets.has(key)) {
        playerCommitMove([r, c]);
        return;
      }
      const piece = state.board[r][c];
      if (pieceBelongsTo(piece, state.playerSide)) {
        const legal = getLegalMoves(state.board, r, c, state.playerSide);
        setHighlight([r, c], legal);
        renderBoard();
      }
    }

    function playerCommitMove([tr, tc]) {
      const from = state.highlight;
      if (!from) return;
      executeMove({ from, to: [tr, tc], side: state.playerSide });
    }

    function showCaptureToast(captured) {
      if (captureToastTimeoutId) clearTimeout(captureToastTimeoutId);
      if (!captured.length) {
        captureToast.classList.remove('visible');
        captureToast.textContent = '';
        return;
      }
      const counts = captured.reduce((acc, entry) => {
        acc[entry.piece] = (acc[entry.piece] || 0) + 1;
        return acc;
      }, {});
      const parts = [];
      if (counts[Piece.ATTACKER]) parts.push(`${counts[Piece.ATTACKER]} attacker${counts[Piece.ATTACKER] > 1 ? 's' : ''}`);
      if (counts[Piece.DEFENDER]) parts.push(`${counts[Piece.DEFENDER]} defender${counts[Piece.DEFENDER] > 1 ? 's' : ''}`);
      if (counts[Piece.KING]) parts.push('the king');
      captureToast.textContent = `Captured ${parts.join(' & ')}`;
      captureToast.classList.add('visible');
      captureToastTimeoutId = setTimeout(() => {
        captureToast.classList.remove('visible');
      }, 2000);
    }

    function setCaptureFlash(captured) {
      if (captureFlashTimeoutId) clearTimeout(captureFlashTimeoutId);
      state.captureFlash = new Set(captured.map(cap => coordKey(cap.r, cap.c)));
      if (!state.captureFlash.size) return;
      captureFlashTimeoutId = setTimeout(() => {
        state.captureFlash.clear();
        renderBoard();
      }, 900);
    }

    function executeMove(move) {
      const { from, to, side } = move;
      const prevPositions = capturePiecePositions();
      const [fr, fc] = from;
      const [tr, tc] = to;
      const movingId = state.idBoard[fr][fc];
      const movedBoard = movePiece(state.board, from, to);
      state.idBoard[fr][fc] = null;
      state.idBoard[tr][tc] = movingId;

      const { board: afterCapture, captured } = captureEnemyPieces(movedBoard, to, side);
      captured.forEach(cap => {
        const capId = state.idBoard[cap.r][cap.c];
        if (capId) {
          const el = piecePool.get(capId);
          if (el) el.remove();
          piecePool.delete(capId);
        }
        state.idBoard[cap.r][cap.c] = null;
      });

      state.board = afterCapture;
      state.lastMove = { from, to };
      clearHighlight();
      setCaptureFlash(captured);

      const repKey = repetitionKey(state.board);
      state.historyKeys.push(repKey);
      const captureSummary = captured.length ? `${captured.length} captured` : '';
      state.moveHistory.push({ ...move, captureSummary });

      renderBoard(prevPositions);
      renderMoves();
      showCaptureToast(captured);

      const repetitionCount = state.historyKeys.filter(key => key === repKey).length;
      if (repetitionCount >= 3 && side === Side.DEFENDERS) {
        endGame(Side.ATTACKERS, 'Perpetual repetition by defenders');
        return;
      }

      const winResult = determineWin(state.board);
      if (winResult) {
        endGame(winResult.winner, winResult.reason);
        return;
      }

      state.currentSide = opposite(state.currentSide);
      updateStatus(`${state.currentSide.charAt(0).toUpperCase() + state.currentSide.slice(1)} to move`, state.currentSide);

      if (state.currentSide !== state.playerSide) {
        requestAIMove();
      }
    }

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function requestAIMove() {
      if (state.gameOver) return;
      const aiMoves = allMoves(state.board, state.currentSide);
      if (!aiMoves.length) {
        const winner = opposite(state.currentSide);
        endGame(winner, `${state.currentSide} cannot move`);
        return;
      }
      setTimeout(() => {
        if (state.gameOver) return;
        const choice = randomChoice(aiMoves);
        executeMove(choice);
      }, 350);
    }

    function endGame(winner, reason) {
      state.gameOver = true;
      updateStatus(`${winner} win · ${reason}`, winner);
    }

    function restartGame() {
      piecePool.forEach(el => el.remove());
      piecePool.clear();
      if (captureToastTimeoutId) clearTimeout(captureToastTimeoutId);
      if (captureFlashTimeoutId) clearTimeout(captureFlashTimeoutId);
      captureToast.classList.remove('visible');
      captureToast.textContent = '';

      const board = initialBoard();
      state = {
        board,
        idBoard: createIdBoard(board),
        currentSide: Side.ATTACKERS,
        playerSide: sideSelect.value,
        highlight: null,
        legalTargets: new Set(),
        lastMove: null,
        moveHistory: [],
        historyKeys: [],
        gameOver: false,
        captureFlash: new Set()
      };
      state.historyKeys.push(repetitionKey(state.board));
      updateStatus('Attackers to move', Side.ATTACKERS);
      renderBoard();
      renderMoves();
      if (state.playerSide !== state.currentSide) {
        requestAIMove();
      }
    }

    restartBtn.addEventListener('click', () => {
      restartGame();
    });

    sideSelect.addEventListener('change', () => {
      restartGame();
    });

    setupBoardGrid();
    restartGame();
  </script>
</body>
</html>
